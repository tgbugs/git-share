#+TITLE: git-share a git repository resolver

#+name: project-description-short
#+header: :results value drawer
#+begin_src elisp :exports results :eval no-export
"A git repository registration service and resolver."
#+end_src

#+RESULTS: project-description-short
:results:
A git repository registration service and resolver.
:end:

* Background
What if I could run =git share= in a repository to tell the world that I had a copy of a
git repository available somewhere? Using the first commit hash of a repo as a unique ID
for that repository (multi-parent aside) resolution to individual copies is the achieved
via a many-to-one mapping from the first commit hash to registered remotes.

=git share --all= could also automatically include all remotes in a =.git/config= as well.

Ids like =git:e6cf3a391686a0b49171b9b195da88e81125bb1e= can be resolved directly,
but there are no guarantees that the target repo will be up to date.

Using this mapping, a PID like
=git:e6cf3a391686a0b49171b9b195da88e81125bb1e:e6cf3a391686a0b49171b9b195da88e81125bb1e=
can be resolved easily if registered remotes have native support for commit resolution,
or at the very least can respond yes or to the question "Do you have a commit with this
hash?" In theory multiple sites could run instrumented repositories to enable this, and
in theory a registry could store the trees of hashes up to the point when =git share= is
run, perhaps as =git share --trees=.

The behavior of =share= could be configured as part of the global git config, of greatest
interest would be configuring which registries to use.

Automated metadata extraction to construct persistable metadata from a git repository is
another potential part of this. One complain about using bare git hashes is that there
isn't any metadata associated with them to provide context for/information about their
referent. In many cases this could be automatically extracted to provide more 'PIDness'
for the pure hash identifiers.

* Design
** endpoints
*** =/sexp=
port 80 endpoint that accepts sexps and nothing else
no http semantics at all
#+begin_src lisp :eval never
(git first-commit-hash ref)
#+end_src
*** =/repo=
**** =/repo/=
**** =/repo/submit=

**** =/resolve=
**** =/resolve/{first-commit}=
**** =/resolve/{first-commit}/{ref}=
in theory we can resolve shortened fragments until things become ambiguous
**** =/resolve?first-commit={first-commit}&ref={ref}=

**** =/git=
**** =/git/{first-commit}=
**** =/git/{first-commit}/{ref}=
in theory we can resolve shortened fragments until things become ambiguous
**** =/git?first-commit={first-commit}&ref={ref}=
* Code
#+name: project-name-base
: git-share

# sigh, inconsistency between eval, tangle, and export
#+name: project-name-safe
: git_share

** elisp
#+name: def-project-name-base
#+header: :noweb yes :results none 
#+begin_src emacs-lisp :exports none
(defun project-name (&optional suffix)
  "project name without - separator"
  (format "%s%s" "<<project-name-base()>>" (or suffix "")))
(defun project-name-base (suffix)
  (format "%s-%s" "<<project-name-base()>>" suffix))
(defun format-safe (string)
  (replace-regexp-in-string
    (regexp-quote "-")
    "_"
    string
    nil 'literal))
(defun project-db-name ()
  "<<db-name>>")
#+end_src

#+call: def-project-name-base()

** SQL
:PROPERTIES:
:header-args:sql: :mkdirp yes
:END:
*** vars
# :eval never is a hack around bad tangle behavior
#+name: schema-name
#+begin_src org :noweb yes
<<project-name-safe()>>
#+end_src

#+name: admin-name
#+begin_src org :noweb yes
<<project-name-base()>>-admin
#+end_src

#+name: user-name
#+begin_src org :noweb yes
<<project-name-base()>>-user
#+end_src

# TODO Change this for production, and/or find a way to branch without export pain.
#+name: db-name
#+begin_src org :noweb yes
<<project-name-safe()>>_test
#+end_src

*** code
:PROPERTIES:
:CREATED:  [2020-01-29 Wed 16:51]
:END:
#+name: postgres
#+header: :engine postgresql
#+header: :dbhost localhost
#+header: :dbuser postgres
#+header: :database postgres
#+header: :cmdline (format "-v database=%s" (project-db-name))
#+begin_src sql :noweb yes :tangle ./sql/postgres.sql
DO
$body$
BEGIN
    IF NOT EXISTS ( SELECT * FROM pg_catalog.pg_user
        WHERE usename = '<<user-name>>') THEN
        CREATE ROLE "<<user-name>>" LOGIN
        NOSUPERUSER INHERIT NOCREATEDB NOCREATEROLE;
    END IF;
    IF NOT EXISTS ( SELECT * FROM pg_catalog.pg_user
        WHERE usename = '<<admin-name>>') THEN
        CREATE ROLE "<<admin-name>>" LOGIN
        NOSUPERUSER INHERIT NOCREATEDB NOCREATEROLE;
    END IF;
END;
$body$ language plpgsql;

ALTER ROLE "<<admin-name>>" SET search_path = <<schema-name>>, public;
ALTER ROLE "<<user-name>>" SET search_path = <<schema-name>>, public;

DROP DATABASE IF EXISTS :database;

CREATE DATABASE :database
    WITH OWNER = '<<admin-name>>'
    ENCODING = 'UTF8'
    TABLESPACE = pg_default
    LC_COLLATE = 'en_US.UTF-8'  -- this was a gentoo locale issue check ${LANG}
    LC_CTYPE = 'en_US.UTF-8'
    CONNECTION LIMIT = -1;
#+end_src

The first time only set passwords and put them in [[file:~/.pgpass]].
This requires interactive session, e.g. via =M-x sql-postgres=.
The [[psql-interactive][psql-interactive]] block below this example will
launch the appropriate interactive session to set the passwords. Your user
will need to have permission to login as =postgres= or you need to have set
the postgres password in [[file:~/.pgpass]] e.g. via a line like
=localhost:5432:*:postgres:the-pg-p4ssw0rd=.

#+header: :dbuser postgres
#+header: :database postgres
#+begin_src sql :noweb yes :eval never
\password <<admin-name>>
\password <<user-name>>
\quit
#+end_src

#+name: psql-interactive
#+header: :results silent
#+begin_src elisp :eval no-export :var this-org-buffer=(buffer-name (current-buffer))
;; required to get the expected behavior when setting passwords
;; otherwise the second prompt "Enter it again:" fails to match
(when (not (string-match "it\\\\\|Response" comint-password-prompt-regexp))
  (setq comint-password-prompt-regexp
        (let ((sl (split-string comint-password-prompt-regexp "Response")))
          (concat (car sl) "it\\|Response" (cadr sl)))))

(setq sql-postgres-login-params
      '((user :default "postgres")
        (database :default "postgres")
        (server :default "localhost")
        (port :default 5432)))
;; TODO this doesn't work due to how orb babel calls elisp NOT due to buffer confusion
;; https://emacs.stackexchange.com/questions/42096/running-elisp-within-an-orgmode-code-block
(let ((buffer (sql-postgres)))
  (with-current-buffer (get-buffer this-org-buffer)
    (split-window-below)
    (windmove-down)
    (switch-to-buffer buffer)))
#+end_src

#+name: extensions
#+header: :engine postgresql
#+header: :dbhost localhost
#+header: :dbuser postgres
#+header: :database (project-db-name)
#+begin_src sql :noweb yes :tangle ./sql/extensions.sql
CREATE EXTENSION uri;
CREATE EXTENSION pgcrypto;
#+end_src

#+name: schemas
#+header: :engine postgresql
#+header: :dbhost localhost
#+header: :dbuser (project-name-base "admin")
#+header: :database (project-db-name)
#+begin_src sql :noweb yes :tangle ./sql/schemas.sql
CREATE SCHEMA IF NOT EXISTS <<schema-name>>;
#+end_src

#+name: tables
#+header: :engine postgresql
#+header: :dbhost localhost
#+header: :dbuser (project-name-base "admin")
#+header: :database (project-db-name)
#+begin_src sql :noweb yes :tangle ./sql/tables.sql
-- wrap table creation in a transaction block to avoid partial failures along the way
-- from resulting in future failures when tables already exist
DO
$body$
BEGIN

CREATE TABLE first_commits(
       first_commit char(40) NOT NULL,
       -- git_remote_uri uri NOT NULL -- FIXME git@github.com:tgbugs/git-share.git breaks this
       git_remote text NOT NULL,
       CONSTRAINT pk__first_commits PRIMARY KEY (first_commit, git_remote)
);

CREATE TABLE remote_trees(
       git_remote text NOT NULL
       -- tree NOT NULL -- TODO
);

CREATE TYPE mirror_type AS enum ('all', 'first-commits', 'none');
CREATE TYPE mirror_mode_type AS enum ('push', 'pull', 'both');

CREATE TABLE registries(
       uri text NOT NULL,
       last_contact timestamp NOT NULL,
       mirror mirror_type NOT NULL,
       mode mirror_mode_type NOT NULL
);

END;
$body$ language plpgsql;
#+end_src

#+name: permissions
#+header: :engine   postgresql
#+header: :dbhost   localhost
#+header: :dbuser   (project-name-base "admin")
#+header: :database (project-db-name)
#+header: :cmdline  (format "-v database=%s" (project-db-name))
#+begin_src sql :noweb yes :tangle ./sql/permissions.sql
GRANT CONNECT
   ON DATABASE :database
   TO "<<user-name>>";

GRANT USAGE
   ON SCHEMA <<schema-name>>
   TO "<<user-name>>";

GRANT SELECT, INSERT
   ON ALL TABLES IN SCHEMA <<schema-name>>
   TO "<<user-name>>";  -- tables includes views

GRANT USAGE
   ON ALL SEQUENCES IN SCHEMA <<schema-name>>
   TO "<<user-name>>";

GRANT INSERT (first_commit, git_remote)
   ON <<schema-name>>.first_commits
   TO "<<user-name>>";
#+end_src

# annoyingly these call blocks all fail with weird bash errors
# because things like (project-db-name) are not evaluated first
# #+call: postgres()
# #+call: extensions()
# #+call: schemas()
# #+call: tables()
# #+call: permissions()

#+header: :shebang "#!/usr/bin/env bash" :mkdirp yes
#+begin_src bash :noweb yes :tangle (format "./bin/%s" (project-name-base "db-setup"))
# TODO sadly this is easier to do in bash
#+end_src

** cl
#+name: package.lisp
#+begin_src lisp :noweb yes :tangle ./package.lisp
(in-package :cl-user)
(defpackage #:<<project-name-base()>>
  (:use
   #:cl
   ; reminder that deps do not go in :use
   ;#:cl-who
   ;#:hunchentoot
   ;#:easy-routes
   ;#:postmodern
)
  (:export #:server-start
           #:server-stop
)
)

(defpackage #:<<project-name-base()>>/daemon
  (:use
   #:cl
   #:<<project-name-base()>>
   ; reminder that deps do not go in :use
   ;#:cl-daemonize
   ;#:swank
))
#+end_src

#+name: project-asd
#+begin_src lisp :noweb yes :tangle (format "./%s" (project-name ".asd"))
(in-package :cl-user)
(defpackage :<<project-name-base()>>-asd
  (:use #:cl #:asdf))
(in-package :<<project-name-base()>>-asd)

(defsystem :<<project-name-base()>>
  :version "0.0.1"
  :author "Tom Gillespie <tgbugs@gmail.com>"
  :license "GPL2"  ; match the git license need to check compat with other things here
  :description <<project-description-short>>
  :depends-on ("cl-who"
               "hunchentoot"
               "easy-routes"
               "postmodern")
  :serial t  ; needed so that packages loads before the others
  :components ((:file "package")
               (:file "core")))

(defsystem :<<project-name-base()>>/daemon
  :depends-on (:<<project-name-base()>>
               "cl-daemonize"
               "swank")
  ;;:components ((:file "daemon"))  ; explicitly don't load the file since it is a script
)

(defsystem :<<project-name-base()>>/test
  :depends-on (:<<project-name-base()>>)
  :components ((:module "test"
                        :serial t
                        :components ((:file "package")
                                     (:file "tests")))))

#+end_src

#+name: parse-args-cli
#+begin_src lisp
(defun pk (element)
  (when (not (listp element))
    (error (format nil "~s not a list!" element)))
  (let* ((kw (car element))
         (sl (string-downcase (symbol-name kw)))
         (assign (cdr element))  ; FIXME default?
         ;;(real-assign (if assign (car assign) (intern (symbol-name kw))))
         (real-assign (intern (symbol-name kw)))
         (default (if assign (car assign) assign)) ; FIXME
         (p (if assign
                `(progn (setq ,real-assign (cadr args)) (setq args (cddr args)))
                `(progn (setq ,real-assign t) (setq args (cdr args))))))
    (list `(,real-assign ,default)
          `(,(intern (format nil "--~a" sl)) ,p)
          `(cons ',real-assign ,real-assign))))

(defmacro parse-args (&body keywords)
  "(parse-args (:port port) (:pid pid) (:flag))"
  ;;(print (apply #'mapcar #'list (map 'list #'pk keywords)))
  ;;(format *standard-output* "~s~%" keywords)
  ;;`(,@keywords)
  `(quote ,keywords)
  (destructuring-bind (defaults cases returns)
      (apply #'mapcar #'list (map 'list #'pk keywords))
    `(let ((args (cdr sb-ext:*posix-argv*))
           ,@defaults)
       (do ()
           ((null args) nil)
         (case (intern (car args))
           ,@cases
           (otherwise (progn (format *standard-output* "unhandled: ~s~%" (car args))
                             (setq args (cdr args))))))
       (list ,@returns))))
#+end_src

#+header: :shebang "#!/usr/bin/sbcl --script" :tangle-mode (identity #o0755)
#+begin_src lisp :noweb yes :tangle ./test
<<parse-args-cli>>
(format *standard-output* "~s~%" sb-ext:*posix-argv*)
(format *standard-output* "~s~%" (parse-args (:qq nil)
                                             (:port 4242)
                                             (:pid "/tmp/<<project-name-base()>>.pid")
                                             (:flag)))
#+end_src

#+begin_src lisp :exports none :eval never
'
(let ((args (cdr sb-ext:*posix-argv*))
      (port 4242)
      (pid  "/run/asdf/pid"))

  (do ()
      ((null args) nil)
    (case (intern (car args))
      (|--port| (progn (setq port (cadr args))
                       (setq args (cddr args))))
      (|--pid| (progn (setq pid (cadr args))
                      (setq args (cddr args))))
      (otherwise (progn (format *standard-output* "unhandled: ~s~%" (car args))
                        (setq args (cdr args))))))
  (print (list port pid)))
#+end_src

#+header: :shebang "#!/usr/bin/sbcl --script"
#+header: :tangle-mode (identity #o0755)
#+begin_src lisp :noweb yes :tangle "./daemon.lisp"
#-quicklisp
(let ((quicklisp-init (merge-pathnames "code/lisp/quicklisp/setup.lisp"
                                       (user-homedir-pathname))))
  (when (probe-file quicklisp-init)
    (load quicklisp-init)))

;(require 'uiop)
;(require 'asdf)

(push (uiop:truenamize #p"~/git/NOFORK/cl-daemonize") ql:*local-project-directories*)
(push (uiop:truenamize #p"~/git/<<project-name-base()>>") ql:*local-project-directories*)
(ql:quickload :<<project-name-base()>>/daemon)
;(ql:quickload :<<project-name-base()>>)
;(ql:quickload '(cl-daemonize swank))
;(push (uiop:truenamize #p"~/git/<<project-name-base()>>") asdf:*central-registry*)
;(asdf:load-system :<<project-name-base()>>/daemon)  ; fixme recursion surely

;(load (uiop:truenamize "~/.emacs.d/elpa/slime-20191224.2328/swank-loader.lisp"))

(in-package :<<project-name-base()>>/daemon)

(defparameter *finished* nil)

<<parse-args-cli>>

(let ((args (parse-args (:port 4242)
                        (:pid #p"/tmp/<<project-name-base()>>.pid")
                        ;; FIXME apparently can't log into the git folder or something !?
                        (:path-log-out #p"/tmp/debug-out.log")
                        (:path-log-err #p"/tmp/debug-err.log"))))
     (defparameter *port* (cdr (assoc 'port args)))
     (defparameter *path-pid* (cdr (assoc 'pid args)))
     (defparameter *path-log-out* (cdr (assoc 'path-log-out args)))
     (defparameter *path-log-err* (cdr (assoc 'path-log-err args)))
)

(format *error-output* "~a ~a~%" *port* *path-pid*)
(format *standard-output* "~a ~a~%" *port* *path-pid*)

(cl-daemonize:daemonize :out *path-log-out* ;"output.log"
                        :err *path-log-err* ;"error.log"
                        :pid *path-pid*
                        :stop (lambda (&rest args)
                                (declare (ignore args))
                                (setf *finished* t)))

;(swank-loader:init)
(swank:create-server :port 4006)
(git-share:server-start :port *port*)

(format *standard-output* "STARTED~%")
(loop :do
     (sleep 1)
     (when *finished*
       (format *standard-output* "DONE~%")
       (git-share:server-stop)
       (sb-ext:quit)))

#+end_src

#+begin_src lisp :noweb yes :tangle ./core.lisp
#-(and)(
        (ql:quickload :cl-who)
        (ql:quickload :hunchentoot)
        (ql:quickload :easy-routes)
        (ql:quickload :postmodern)
        (rename-package :postmodern :postmodern '(psql))
        )
(in-package :<<project-name-base()>>)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (rename-package :postmodern :postmodern '(psql)))

#-(and)
(defparameter *db-connection* (psql:connect-toplevel
                               <<db-name>>
                               "<<user-name>>"
                               "TODO-pgpass"
                               "localhost"
                               :port 5432))
(defparameter *db-connection* (psql:connect-toplevel "<<db-name>>" "<<user-name>>" "gsu123" "localhost"))
(defvar *acceptor* nil)

(defun server-start (&key (port 4242))
  (server-stop)
  (hunchentoot:start (setf *acceptor*
                           (make-instance 'easy-routes:routes-acceptor
                                          :port port))))

(defun server-stop ()
  (when *acceptor*
    (when (hunchentoot:started-p *acceptor*)
      (hunchentoot:stop *acceptor*))))

(defun format-git-id (first-commit &optional (ref ""))
  (format nil "Id: git:~a:~a" first-commit ref))

;;; queries
(require 'cl-postgres-error)

(defun query-insert-fc (first-commit git-remote)
  (handler-bind
      (
       (cl-postgres-error:unique-violation (lambda (condition)
                                            (declare (ignore condition))
                                            (print "aaaaaaaaaaa 1")
                                            ;(abort-web 200)
                                            (setf (hunchentoot:return-code*) 200)
                                            ;(invoke-restart 'continue)
                                            (ignore-errors)
                                            ;(invoke-restart 'abort)
                                            (print "aaaaaaaaaaa 2")
))
       ;(cl-postgres-error:unique-violation (lambda (condition) (abort-web 200)))
       ;(error (lambda (condition) (print "argh") (print condition) (error condition)))
)
    (psql:query (:insert-rows-into 'first_commits
                          :columns 'first_commit 'git_remote
                           :values (list (list first-commit git-remote))))))

;; TODO (handler-bind (cl-postgres-error::* #'some-handler))
(defun query-select-fc-remotes (first-commit)
  (psql:query (:select 'git_remote
                 :from 'first_commits
                :where (:= 'first_commit first-commit))))

(defun query-select-id-remotes (first-commit &optional ref)
  ;; TODO
  (query-select-fc-remotes first-commit))

;;; helpers

(defun abort-db (condition)
  ;; TODO
  (abort-web 500))

(defun abort-web (&optional code)
  (setf (hunchentoot:return-code*) code)
  (hunchentoot:abort-request-handler))

(defun parse-id (id)
  (destructuring-bind (&optional type first-commit ref)
      (uiop:split-string id :separator ":")
      (format *standard-output* "~s ~s ~s" type first-commit ref)
    (cond ((string= type "git")
           (if ref  ; implies first-commit
               (query-select-id-remotes first-commit ref)
               (if (and first-commit (not (string= first-commit "")))
                   (query-select-fc-remotes first-commit)
                   (abort-web 404))))
          (t (abort-web 404)))))

;;; routes
(easy-routes:defroute
 post-git-fc ("/git/:first-commit" :method :post) (remote)
 (setf (hunchentoot:content-type*) "text/plain")
 ;; if known remote pattern check for first commit
 ;; if config parameter set to check all clone and validate first commit
 ;; if everything checks out add remote and first commit to database
 (setf (hunchentoot:return-code*) 201)  ; 200 returns on unique constraint violation
 (ignore-errors  ; WHY DO WE HAVE TO USE THIS !?!?!!
 (query-insert-fc first-commit remote))
 ;; wow ... it just... works ...
 (format nil "Register: git:~a -> ~a" first-commit remote))

(easy-routes:defroute get-resolve-id
 ("/resolve/:id" :method :get) ()
 (setf (hunchentoot:content-type*) "text/plain")
 (format nil "Id ~a -> ~a" id (parse-id id)))

(easy-routes:defroute get-git-fc
 ("/git/:first-commit" :method :get) ()
 (setf (hunchentoot:content-type*) "text/plain")
 (let ((results (query-select-fc-remotes first-commit)))
   (format nil "Id: git:~a -> ~a" first-commit results)))

(easy-routes:defroute get-git-fc-ref
 ("/git/:first-commit/:ref" :method :get) ()
 (setf (hunchentoot:content-type*) "text/plain")
 (format-git-id first-commit ref))
#+end_src

*** test
#+begin_src bash
curl -X POST http://localhost:4242/git/e6cf3a391686a0b49171b9b195da88e81125bb1e?remote=https://github.com/tgbugs/git-share.git
#+end_src

#+RESULTS:
: Register: git:e6cf3a391686a0b49171b9b195da88e81125bb1e -> https://github.com/tgbugs/git-share.git


#+begin_src bash
curl -X GET http://localhost:4242/git/e6cf3a391686a0b49171b9b195da88e81125bb1e
#+end_src

#+begin_src lisp
(psql:query (:select '* :from 'first_commits))
#+end_src

#+begin_src lisp
(psql:query "INSERT INTO first_commits (first_commit, git_remote)
                    VALUES ('6d96945e85d4e949215910f13f3e620495b5e165',
                            'https://github.com/tgbugs/pyontutils.git')")
#+end_src

** bash
NOTE there can be more than one first commit
#+begin_src bash
function git-share-first-commit () {
    FC=$(git rev-list --max-parents=0 HEAD)
    for remote in $(git remote get-url --all origin); do
        curl -X POST "http://localhost:4242/git/${FC}?remote=${remote}"
    done
    # TODO always push to the local git-share instance first (sigh c)
    # and that will then deal with connecting to federated servers
}
function git-share-all () {
    git remote get-url --all origin
}
# git-share-first-commit
# git-share-all
#+end_src

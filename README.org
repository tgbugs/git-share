#+TITLE: git-share a git repository resolver

# FIXME this needs to be called before tangling can continue ... how safely ...
#+call: def-project-name-base()

#+name: project-description-short
#+header: :results value drawer
#+begin_src elisp :exports results :eval no-export
"A git repository registration service and resolver."
#+end_src

#+RESULTS: project-description-short
:results:
A git repository registration service and resolver.
:end:

* Background
What if I could run =git share= in a repository to tell the world that I had a copy of a
git repository available somewhere? Using the first commit hash of a repo as a unique ID
for that repository (multi-parent aside) resolution to individual copies is the achieved
via a many-to-one mapping from the first commit hash to registered remotes.

=git share --all= could also automatically include all remotes in a =.git/config= as well.

Ids like =git:e6cf3a391686a0b49171b9b195da88e81125bb1e= can be resolved directly,
but there are no guarantees that the target repo will be up to date.

Using this mapping, a PID like
=git:e6cf3a391686a0b49171b9b195da88e81125bb1e:e6cf3a391686a0b49171b9b195da88e81125bb1e=
can be resolved easily if registered remotes have native support for commit resolution,
or at the very least can respond yes or to the question "Do you have a commit with this
hash?" In theory multiple sites could run instrumented repositories to enable this, and
in theory a registry could store the trees of hashes up to the point when =git share= is
run, perhaps as =git share --trees=.

The behavior of =share= could be configured as part of the global git config, of greatest
interest would be configuring which registries to use.

Automated metadata extraction to construct persistable metadata from a git repository is
another potential part of this. One complain about using bare git hashes is that there
isn't any metadata associated with them to provide context for/information about their
referent. In many cases this could be automatically extracted to provide more 'PIDness'
for the pure hash identifiers.

* Design
** issues
Validation that the remote's first commit matches the asserted value is important.
If there is a trusted process that is making the submissions that would work as well.
You could pretty much have a giant batch of crawlers for these since there isn't really
a need to keep the data around, clone the repo and find the parentless commits for all
heads, submit/validate the entry in the database, and then rm the repo and go get the next one.

If using =git-share= in a local agent configuration (not yet implemented) then this
is less relevant since the crawler and the submitter are essentially the same. When
coordinating between nodes run by individuals we will have to deal with the validation and
verification issue as well.

If it turns out that something like this is useful, it might make sense to try to get
it implemented as part of the stock information that remote git repos can answer without
having to get the whole repo.
** endpoints
*** =/sexp=
port 80 endpoint that accepts sexps and nothing else
no http semantics at all
#+begin_src lisp :eval never
(git first-commit-hash ref)
#+end_src
*** =/repo=
**** =/repo/=
**** =/repo/submit=
**** =/resolve=
**** =/resolve/{first-commit}=
**** =/resolve/{first-commit}/{ref}=
in theory we can resolve shortened fragments until things become ambiguous
**** =/resolve?first-commit={first-commit}&ref={ref}=
**** =/git=
**** =/git/{first-commit}=
**** =/git/{first-commit}/{ref}=
in theory we can resolve shortened fragments until things become ambiguous
**** =/git?first-commit={first-commit}&ref={ref}=
* Setup
Git share uses the =pguri= extension. On Gentoo you can install it with the following.

#+begin_src bash
layman -a tgbugs-overlay
emerge pguri
#+end_src
* Code
#+name: project-name-base
: git-share

# sigh, inconsistency between eval, tangle, and export
#+name: project-name-safe
: git_share

** elisp
#+name: def-project-name-base
#+header: :noweb yes :results value :cache yes :lexical yes
#+begin_src emacs-lisp :exports none :var reset=(identity nil)
(when (or (not (boundp '--git-share-elisp-loaded)) reset)
(defun project-name (&optional suffix)
  "project name without - separator"
  (format "%s%s" "<<project-name-base()>>" (or suffix "")))
(defun project-name-base (suffix)
  (format "%s-%s" "<<project-name-base()>>" suffix))
(defun format-safe (string)
  (replace-regexp-in-string
    (regexp-quote "-")
    "_"
    string
    nil 'literal))
(defun project-db-name ()
  "<<db-name>>")
(setq --git-share-elisp-loaded (if reset (current-time-string) t)))
#+end_src

** SQL
:PROPERTIES:
:header-args:sql: :mkdirp yes
:END:
*** vars
# :eval never is a hack around bad tangle behavior
#+name: schema-name
#+begin_src org :noweb yes
<<project-name-safe()>>
#+end_src

#+name: admin-name
#+begin_src org :noweb yes
<<project-name-base()>>-admin
#+end_src

#+name: user-name
#+begin_src org :noweb yes
<<project-name-base()>>-user
#+end_src

# TODO Change this for production, and/or find a way to branch without export pain.
#+name: db-name
#+begin_src org :noweb yes
<<project-name-safe()>>_test
#+end_src

*** code
:PROPERTIES:
:CREATED:  [2020-01-29 Wed 16:51]
:header-args: :comments link
:END:
#+name: postgres
#+header: :engine postgresql
#+header: :dbhost localhost
#+header: :dbuser postgres
#+header: :database postgres
#+header: :cmdline (format "-v database=%s" (project-db-name))
#+begin_src sql :noweb yes :tangle ./sql/postgres.sql
DO
$body$
BEGIN
    IF NOT EXISTS ( SELECT * FROM pg_catalog.pg_user
        WHERE usename = '<<user-name>>') THEN
        CREATE ROLE "<<user-name>>" LOGIN
        NOSUPERUSER INHERIT NOCREATEDB NOCREATEROLE;
    END IF;
    IF NOT EXISTS ( SELECT * FROM pg_catalog.pg_user
        WHERE usename = '<<admin-name>>') THEN
        CREATE ROLE "<<admin-name>>" LOGIN
        NOSUPERUSER INHERIT NOCREATEDB NOCREATEROLE;
    END IF;
END;
$body$ language plpgsql;

ALTER ROLE "<<admin-name>>" SET search_path = <<schema-name>>, public;
ALTER ROLE "<<user-name>>" SET search_path = <<schema-name>>, public;

DROP DATABASE IF EXISTS :database;

CREATE DATABASE :database
    WITH OWNER = '<<admin-name>>'
    ENCODING = 'UTF8'
    TABLESPACE = pg_default
    LC_COLLATE = 'en_US.UTF-8'  -- this was a gentoo locale issue check ${LANG}
    LC_CTYPE = 'en_US.UTF-8'
    CONNECTION LIMIT = -1;
#+end_src

The first time only set passwords and put them in [[file:~/.pgpass]].
This requires interactive session, e.g. via =M-x sql-postgres=.
The [[psql-interactive][psql-interactive]] block below this example will
launch the appropriate interactive session to set the passwords. Your user
will need to have permission to login as =postgres= or you need to have set
the postgres password in [[file:~/.pgpass]] e.g. via a line like
=localhost:5432:*:postgres:the-pg-p4ssw0rd=.

#+header: :dbuser postgres
#+header: :database postgres
#+begin_src sql :noweb yes :eval never
\password '<<admin-name>>'
\password '<<user-name>>'
\quit
#+end_src

#+name: psql-interactive
#+header: :results silent
#+begin_src elisp :eval no-export :var this-org-buffer=(buffer-name (current-buffer))
;; required to get the expected behavior when setting passwords
;; otherwise the second prompt "Enter it again:" fails to match
(when (not (string-match "it\\\\\|Response" comint-password-prompt-regexp))
  (setq comint-password-prompt-regexp
        (let ((sl (split-string comint-password-prompt-regexp "Response")))
          (concat (car sl) "it\\|Response" (cadr sl)))))

;; TODO this doesn't work due to how orb babel calls elisp NOT due to buffer confusion
;; https://emacs.stackexchange.com/questions/42096/running-elisp-within-an-orgmode-code-block
(let* ((sql-postgres-login-params
        '((user :default "postgres")
          (database :default "postgres")
          (server :default "localhost")
          (port :default 54321)))
       (buffer (sql-postgres)))
  (with-current-buffer (get-buffer this-org-buffer)
    (split-window-below)
    (windmove-down)
    (switch-to-buffer buffer)))
#+end_src

#+name: extensions
#+header: :engine postgresql
#+header: :dbhost localhost
#+header: :dbuser postgres
#+header: :database (project-db-name)
#+begin_src sql :noweb yes :tangle ./sql/extensions.sql
CREATE EXTENSION uri;
CREATE EXTENSION pgcrypto;
#+end_src

#+name: schemas
#+header: :engine postgresql
#+header: :dbhost localhost
#+header: :dbuser (project-name-base "admin")
#+header: :database (project-db-name)
#+begin_src sql :noweb yes :tangle ./sql/schemas.sql
CREATE SCHEMA IF NOT EXISTS <<schema-name>>;
#+end_src

#+name: tables
#+header: :engine postgresql
#+header: :dbhost localhost
#+header: :dbuser (project-name-base "admin")
#+header: :database (project-db-name)
#+begin_src sql :noweb yes :tangle ./sql/tables.sql
-- wrap table creation in a transaction block to avoid partial failures along the way
-- from resulting in future failures when tables already exist
DO
$body$
BEGIN

CREATE TABLE first_commits(
       first_commit char(40) NOT NULL,
       -- git_remote_uri uri NOT NULL -- FIXME git@github.com:tgbugs/git-share.git breaks this
       git_remote text NOT NULL,
       CONSTRAINT pk__first_commits PRIMARY KEY (first_commit, git_remote)
);

CREATE TABLE remote_trees(
       git_remote text NOT NULL
       -- tree NOT NULL -- TODO
);

CREATE TYPE mirror_type AS enum ('all', 'first-commits', 'none');
CREATE TYPE mirror_mode_type AS enum ('push', 'pull', 'both');

CREATE TABLE registries(
       uri text NOT NULL,
       last_contact timestamp NOT NULL,
       mirror mirror_type NOT NULL,
       mode mirror_mode_type NOT NULL
);

END;
$body$ language plpgsql;
#+end_src

#+name: permissions
#+header: :engine   postgresql
#+header: :dbhost   localhost
#+header: :dbuser   (project-name-base "admin")
#+header: :database (project-db-name)
#+header: :cmdline  (format "-v database=%s" (project-db-name))
#+begin_src sql :noweb yes :tangle ./sql/permissions.sql
GRANT CONNECT
   ON DATABASE :database
   TO "<<user-name>>";

GRANT USAGE
   ON SCHEMA <<schema-name>>
   TO "<<user-name>>";

GRANT SELECT, INSERT
   ON ALL TABLES IN SCHEMA <<schema-name>>
   TO "<<user-name>>";  -- tables includes views

GRANT USAGE
   ON ALL SEQUENCES IN SCHEMA <<schema-name>>
   TO "<<user-name>>";

GRANT INSERT (first_commit, git_remote)
   ON <<schema-name>>.first_commits
   TO "<<user-name>>";
#+end_src

# annoyingly these call blocks all fail with weird bash errors
# because things like (project-db-name) are not evaluated first
# #+call: postgres()
# #+call: extensions()
# #+call: schemas()
# #+call: tables()
# #+call: permissions()

#+header: :shebang "#!/usr/bin/env bash" :mkdirp yes
#+begin_src bash :noweb yes :tangle (format "./bin/%s" (project-name-base "db-setup"))
# TODO sadly this is easier to do in bash
#+end_src

** cl
:properties:
:header-args: :comments link
:end:
# sadly the force eval hack doesn't work
# because org looks for the project-name-* functions first
# :var --force-eval-hack=def-project-name-base()
# :header-args: :comments link :var __FORCE_EVAL_HACK=def-project-name-base()
*** packages
#+name: package.lisp
#+begin_src lisp :noweb yes :tangle ./package.lisp
(in-package :cl-user)
(defpackage #:<<project-name-base()>>
  (:use
   #:cl
   ; reminder that deps do not go in :use
   ;#:cl-who
   ;#:hunchentoot
   ;#:easy-routes
   ;#:postmodern
)
  (:export #:server-start
           #:server-stop
)
)

(defpackage #:<<project-name-base()>>/daemon
  (:use
   #:cl
   #:<<project-name-base()>>
   ; reminder that deps do not go in :use
   ;#:cl-daemonize
   ;#:swank
))
#+end_src

#+name: project-asd
#+header: :eval never
#+begin_src lisp :noweb yes :tangle (format "./%s" (project-name ".asd"))
(in-package :cl-user)
(defpackage :<<project-name-base()>>-asd
  (:use #:cl #:asdf))
(in-package :<<project-name-base()>>-asd)

(defsystem :<<project-name-base()>>
  :version "0.0.1"
  :author "Tom Gillespie <tgbugs@gmail.com>"
  :license "GPL2"  ; match the git license need to check compat with other things here
  :description <<project-description-short>>
  :depends-on ("cl-who"
               "hunchentoot"
               "easy-routes"
               "postmodern")
  :serial t  ; needed so that packages loads before the others
  :components ((:file "package")
               (:file "core")))

#+()
(defsystem :<<project-name-base()>>/daemon
  :depends-on (:<<project-name-base()>>
               "cl-daemonize"
               "swank")
  ;;:components ((:file "daemon"))  ; explicitly don't load the file since it is a script
)

(defsystem :<<project-name-base()>>/start-small
  ;; Confusingly this includes no files and is loaded using `ql:quickoad'
  ;; in bootstrap-image.lisp simply to pull in the swank dependency .
  ;; I'm not sure if this is the right way to do this, but it works.
  :depends-on (:<<project-name-base()>>
               "swank"))

(defsystem :<<project-name-base()>>/bootstrap-helper
  ;; bootstrap-image cannot be listed as a component
  ;; because some kind of circularity makes it impossible
  ;; for the pk function to be found during compile
  :depends-on (:<<project-name-base()>>
               "swank"))

(defsystem :<<project-name-base()>>/test
  :depends-on (:<<project-name-base()>>)
  :components ((:module "test"
                        :serial t
                        :components ((:file "package")
                                     (:file "tests")))))

#+end_src
*** parse args
#+name: parse-args-cli
#+begin_src lisp
(defun norm-arg (arg)
  ; FIXME type decls here would help
  ; FIXME parse-integer ignores leading zeros!
  (let ((int (ignore-errors (parse-integer arg))))
    (if int int arg)))

(defun pk (element)
  (when (not (listp element))
    (error (format nil "~s not a list!" element)))
  (let* ((kw (car element))
         (sl (string-downcase (symbol-name kw)))
         (assign (cdr element))  ; FIXME default?
         ;;(real-assign (if assign (car assign) (intern (symbol-name kw))))
         (real-assign (intern (symbol-name kw)))
         (default (if assign (car assign) assign)) ; FIXME
         (p (if assign
                `(progn (setq ,real-assign (norm-arg (cadr args))) (setq args (cddr args)))
                `(progn (setq ,real-assign t) (setq args (cdr args))))))
    (list `(,real-assign ,default)
          `(,(intern (format nil "--~a" sl)) ,p)
          `(cons ',real-assign ,real-assign))))

(defmacro parse-args (&body keywords)
  "(parse-args (:port port) (:pid pid) (:flag))"
  ;;(print (apply #'mapcar #'list (map 'list #'pk keywords)))
  ;;(format *standard-output* "~s~%" keywords)
  ;;`(,@keywords)
  `(quote ,keywords)
  (destructuring-bind (defaults cases returns)
      (apply #'mapcar #'list (map 'list #'pk keywords))
    `(let ((args (cdr #+ecl (loop for n from 0 below (si:argc) collect (si:argv n))
                      #+sbcl sb-ext:*posix-argv*))
           ,@defaults)
       (do ()
           ((null args) nil)
         (case (intern (car args))
           ,@cases
           (otherwise (progn (format *standard-output* "unhandled: ~s~%" (car args))
                             (setq args (cdr args))))))
       (list ,@returns))))
#+end_src

While we're here, some crazy stuff on shebangs.
<https://stackoverflow.com/questions/4303128/
how-to-use-multiple-arguments-for-awk-with-a-shebang-i-e>

#+header: :shebang "#!/usr/bin/env -S sbcl --script" :tangle-mode (identity #o0755)
#+begin_src lisp :noweb yes :tangle ./args-test :results output
<<parse-args-cli>>
(format *standard-output* "~s~%" sb-ext:*posix-argv*)
(format *standard-output* "~s~%" (parse-args (:qq nil)
                                             (:port 4242)
                                             (:pid "/tmp/<<project-name-base()>>.pid")
                                             (:flag)))
(format t "~s~%" *compile-file-truename*)
(format t "~s~%" *compile-file-pathname*)
#+end_src

#+header: :shebang "#!/usr/bin/env -S ecl -q -norc -shell"
#+begin_src lisp  :noweb yes :tangle ./args-test-ecl :results output
<<parse-args-cli>>
(format *standard-output* "~s~%" (loop for n from 0 below (si:argc) collect (si:argv n)))
(format *standard-output* "~s~%" (parse-args (:qq nil)
                                             (:port 4242)
                                             (:pid "/tmp/<<project-name-base()>>.pid")
                                             (:flag)))
(format t "~s~%" *compile-file-truename*)
(format t "~s~%" *compile-file-pathname*)
#+end_src

#+begin_src lisp :exports none :eval never
'
(let ((args (cdr sb-ext:*posix-argv*))
      (port 4242)
      (pid  "/run/asdf/pid"))

  (do ()
      ((null args) nil)
    (case (intern (car args))
      (|--port| (progn (setq port (cadr args))
                       (setq args (cddr args))))
      (|--pid| (progn (setq pid (cadr args))
                      (setq args (cddr args))))
      (otherwise (progn (format *standard-output* "unhandled: ~s~%" (car args))
                        (setq args (cdr args))))))
  (print (list port pid)))
#+end_src
*** development
**** slime
# FIXME probably better to use asdf:load-system
# even in this context ...
#+name: slime-repl-setup
#+begin_src lisp
(ql:quickload :cl-who)
(ql:quickload :hunchentoot)
(ql:quickload :easy-routes)
(ql:quickload :postmodern)
(rename-package :postmodern :postmodern '(psql))
(defpackage #:git-share
  (:use :cl)
  (:export #:server-start
           #:server-stop))
#+end_src

#+name: slime-repl-devel
#+caption: run this block if you are going to be doing interactive development in the repl
#+header: :comments link :results none
#+begin_src lisp :noweb yes
(setq hunchentoot:*catch-errors-p* nil)
<<core>>
(git-share:server-start :port 4242)
#+end_src

When you are done you can run the following block.
#+name: slime-repl-devel-stop
#+begin_src lisp
(git-share:server-stop)
#+end_src

For whatever reason we still need ref:slime-repl-setup.
I still have no idea how to get org-bable to execute the quickload
bits first and the rest later if it is all sent in one block. Also
the first time loading these it can make more sense to execute them
manually so that you get an interactive debugging session in the event
that something goes wrong.

The ref:slime-repl-devel block only needs to be run once, after that any
further modifications can be made by executing the ref:core or any of
the other blocks block again without needing to run this block again.

Also apparently if we don't do testing in =cl-user= or something like that then
there is a problem finding the database connection? Pretty sure that is a bug on my end.

# Hrm, maybe the issue is that I need to add an eval-when compile to the quickloads?
# yes it would seem so, but then there is the issue that if you run this in the same
# emacs client you are clicking an org-link from you have to C-g out of the org link
# resolution code in order to debug in slime. Sigh async emacs.

*** deployment
**** SLaD
So. Of all the many ways that one can try to package this thing to run
this is the one that amuses me the most deeply. 15mb. Sure you need a
copy of sbcl on the server, but still ... wow.

Tangle and run build-image to create a core dump that can be loaded on another system.

And WOW the memory savings compared to running the =start-small= version.
Obviously a tradeoff in there somewhere, but seriously wow.

#+name: build-sbcl
#+header: :shebang "#!/usr/bin/sbcl --script"
#+header: :tangle-mode (identity #o0755)
#+begin_src lisp :noweb yes :tangle ./build-image
(load "bootstrap-image.lisp")
#-quicklisp
(let ((quicklisp-init (merge-pathnames "code/lisp/quicklisp/setup.lisp"
                                       (user-homedir-pathname))))
  (when (probe-file quicklisp-init)
    (load quicklisp-init)))
;;(push (uiop:truenamize "./") asdf:*central-registry*)
#+()
(push (uiop:truenamize #p"~/git/<<project-name-base()>>") ql:*local-project-directories*)  ; FIXME
#+()
(ql:quickload :<<project-name-base()>>/bootstrap-image)
(save-lisp-and-die "git-share-start-small" :toplevel #'main :executable t :compression t)
#+end_src

#+begin_src lisp :noweb yes :tangle ./bootstrap-image.lisp
#-quicklisp
(let ((quicklisp-init (merge-pathnames "code/lisp/quicklisp/setup.lisp"
                                       (user-homedir-pathname))))
  (when (probe-file quicklisp-init)
    (load quicklisp-init)))

(push (uiop:truenamize #p"~/git/<<project-name-base()>>") ql:*local-project-directories*)
;;(ql:quickload :<<project-name-base()>>/start-small)
(ql:quickload :<<project-name-base()>>/bootstrap-image)

(defparameter *finished* nil)

<<parse-args-cli>>

(defun main ()
  (format t "~s~%" sb-ext:*posix-argv*)
  (let* ((args (parse-args (:port 4242)
                           (:pid #p"/tmp/<<project-name-base()>>.pid")
                           (:port-swank 4006)))
         (*port* (cdr (assoc 'port args)))
         (*path-pid* (cdr (assoc 'pid args)))
         (*port-swank* (cdr (assoc 'port-swank args))))
    (swank:create-server :port *port-swank*)
    (git-share:server-start :port *port*))

  (format t "STARTED~%")
  (loop :do
       (sleep 5)
       (when *finished*
         (format t "DONE~%")
         (git-share:server-stop)
         #+ecl
         (si:exit)
         #+sbcl
         (sb-ext:quit))))
#+end_src

It seems like =app-misc/detachtty= may be needed to get this to work.
Or the eternal loop might work as well. Needs more testing.

#+name: open-rc-init-script-slad
#+begin_src bash :tangle ./git-share-slad.rc
#!/sbin/openrc-run
# Copyright 1999-2020 Gentoo Authors
# Distributed under the terms of the GNU General Public License v2

: ${LOG_LEVEL:=info}
: ${SVCGROUP:=git-share}
: ${SVCUSER:=git-share}
: ${LOG_LOC:="/var/log/git-share"}

run_dir=${run_dir:-/run}
LOG="${LOG_LOC}/sysout.log"

pidfile="${run_dir}/${SVCNAME}/pid"
start_stop_daemon_args="
--group ${SVCGROUP}
--user ${SVCUSER}
--wait 1000
--env DOWENEEDENV=${SOMEENV}
"
command="/usr/bin/sbcl"
command_args="--port ${PORT}
--port-swank ${PORT_SWANK}"
retry='TERM/30/KILL/5'

command_owner="${SVCUSER}:${SVCGROUP}"

depend() {
    after net
}

start_pre() {
    local OOPS=0
    if [[ "${HRM_API}" == *"some-value"* ]] && [ -z "${HRM_KEY}" ]; then
        eend 1 durn
        OOPS=1
    fi
    if [ ${OOPS} -ne 0 ]; then
        return 1
    fi
    checkpath --directory --owner ${command_owner} --mode 0775 "/run/${SVCNAME}"
    checkpath --directory --owner ${command_owner} --mode 0775 "${LOG_LOC}"
}
#+end_src
**** foreground
Maybe a smaller version that uses openrc instead of self daemonizing
to be a bit friendly/more interoperable with posix conventions?
http://theatticlight.net/posts/A-Lisp-Daemon/
https://www.darkchestnut.com/2016/daemonizing-common-lisp-services/
https://www.reddit.com/r/Common_Lisp/comments/4n7ly6/daemonizing_common_lisp_services/

#+name: start-small
#+header: :shebang "#!/usr/bin/sbcl --script"
#+header: :tangle-mode (identity #o0755)
#+begin_src lisp :noweb yes :tangle ./start-small.lisp
#-quicklisp
(let ((quicklisp-init (merge-pathnames "code/lisp/quicklisp/setup.lisp"
                                       (user-homedir-pathname))))
  (when (probe-file quicklisp-init)
    (load quicklisp-init)))

(push (uiop:truenamize #p"~/git/<<project-name-base()>>") ql:*local-project-directories*)
(ql:quickload :<<project-name-base()>>/start-small)

<<parse-args-cli>>

(let ((args (parse-args (:port 4242)
                        (:pid #p"/tmp/<<project-name-base()>>.pid")
                        ;; FIXME apparently can't log into the git folder or something !?
                        ;;(:path-log-out #p"/tmp/debug-out.log")
                        ;;(:path-log-err #p"/tmp/debug-err.log")
                        ;; log to sysout in daemon for this one
                        )))
  (defparameter *port* (cdr (assoc 'port args)))
  (defparameter *path-pid* (cdr (assoc 'pid args)))
  (defparameter *path-log-out* (cdr (assoc 'path-log-out args)))
  (defparameter *path-log-err* (cdr (assoc 'path-log-err args))))

(defparameter *finished* nil)

(swank:create-server :port 4006)
(git-share:server-start :port *port*)

(format *standard-output* "STARTED~%")
(loop :do
     (sleep 5)
     (when *finished*
       (format *standard-output* "DONE~%")
       (git-share:server-stop)
       (sb-ext:quit)))
#+end_src

#+name: open-rc-init-script
#+begin_src bash :tangle ./git-share.rc
#!/sbin/openrc-run
# Copyright 1999-2020 Gentoo Authors
# Distributed under the terms of the GNU General Public License v2

: ${LOG_LEVEL:=info}
: ${SVCGROUP:=git-share}
: ${SVCUSER:=git-share}
: ${LOG_LOC:="/var/log/git-share"}

run_dir=${run_dir:-/run}
LOG="${LOG_LOC}/${SVCNAME}.log"

socket="unix:/run/${SVCNAME}/socket"

pidfile="${run_dir}/${SVCNAME}/pid"
start_stop_daemon_args="
--group ${SVCGROUP}
--user ${SVCUSER}
--wait 1000
--env DOWENEEDENV=${SOMEENV}
"
command="/usr/bin/sbcl"
command_args="--bind ${socket}
--port ${PORT}
--pid ${pidfile}"
retry='TERM/30/KILL/5'

command_owner="${SVCUSER}:${SVCGROUP}"

depend() {
    after net
}

start_pre() {
    OOPS=0
    if [ -z "${SCIGRAPH_API}" ]; then
        eend 1 "SCIGRAPH_API is not set in /etc/conf.d/${SVCNAME}"
        OOPS=1
    fi
    if [[ "${SCIRGRAPH_API}" == *"scicrunch"* ]] && [ -z "${SCIGRAPH_API_KEY}" ]; then
        eend 1 "SCIGRAPH_API requires SCIGRAPH_API_KEY not set in /etc/conf.d/${SVCNAME}"
        OOPS=1
    fi
    if [ ${OOPS} -ne 0 ]; then
        return 1
    fi
    checkpath --directory --owner ${command_owner} --mode 0775 "/run/${SVCNAME}"
    checkpath --directory --owner ${command_owner} --mode 0775 "${LOG_LOC}"
}
#+end_src
**** ecl
The best reference for this is
<https://common-lisp.net/project/ecl/static/manual/
System-building.html#Compiling-with-ECL> and the =asdf:make-build=
option seems to be the best for our use case.

# a good reference for shebangs https://www.cliki.net/Unix%20shell%20scripting
# #+header: :tangle-mode (identity #o0755)
#+name: build-ecl
#+header: :shebang "#!/usr/bin/env -S ecl -q -norc -shell"
#+begin_src lisp :tangle ./build-ecl
(asdf:make-build :git-share/start-small
                 :type :program
                 :monolithic t  ;;
                 :move-here #P"./"
                 :epilogue-code '(main))
#+end_src
#+begin_src lisp
#+ecl
(progn
(require 'cmp)
(c:build-program "somewhere-else" "test-ecl.lisp")
)
#+end_src
**** daemon :old:
self daemonizing approach
#+header: :shebang "#!/usr/bin/sbcl --script"
#+header: :tangle-mode (identity #o0755)
#+begin_src lisp :noweb yes :tangle "./daemon.lisp"
#-quicklisp
(let ((quicklisp-init (merge-pathnames "code/lisp/quicklisp/setup.lisp"
                                       (user-homedir-pathname))))
  (when (probe-file quicklisp-init)
    (load quicklisp-init)))

;(require 'uiop)
;(require 'asdf)

(push (uiop:truenamize #p"~/git/NOFORK/cl-daemonize") ql:*local-project-directories*)
(push (uiop:truenamize #p"~/git/<<project-name-base()>>") ql:*local-project-directories*)
(ql:quickload :<<project-name-base()>>/daemon)
;(ql:quickload :<<project-name-base()>>)
;(ql:quickload '(cl-daemonize swank))
;(push (uiop:truenamize #p"~/git/<<project-name-base()>>") asdf:*central-registry*)
;(asdf:load-system :<<project-name-base()>>/daemon)  ; fixme recursion surely

;(load (uiop:truenamize "~/.emacs.d/elpa/slime-20191224.2328/swank-loader.lisp"))

(in-package :<<project-name-base()>>/daemon)

(defparameter *finished* nil)

<<parse-args-cli>>

(let ((args (parse-args (:port 4242)
                        (:pid #p"/tmp/<<project-name-base()>>.pid")
                        ;; FIXME apparently can't log into the git folder or something !?
                        (:path-log-out #p"/tmp/debug-out.log")
                        (:path-log-err #p"/tmp/debug-err.log"))))
     (defparameter *port* (cdr (assoc 'port args)))
     (defparameter *path-pid* (cdr (assoc 'pid args)))
     (defparameter *path-log-out* (cdr (assoc 'path-log-out args)))
     (defparameter *path-log-err* (cdr (assoc 'path-log-err args)))
)

(format *error-output* "~a ~a~%" *port* *path-pid*)
(format *standard-output* "~a ~a~%" *port* *path-pid*)

(cl-daemonize:daemonize :out *path-log-out* ;"output.log"
                        :err *path-log-err* ;"error.log"
                        :pid *path-pid*
                        :stop (lambda (&rest args)
                                (declare (ignore args))
                                (setf *finished* t)))

;(swank-loader:init)
(swank:create-server :port 4006)
(git-share:server-start :port *port*)

(format *standard-output* "STARTED~%")
(loop :do
     (sleep 1)
     (when *finished*
       (format *standard-output* "DONE~%")
       (git-share:server-stop)
       (sb-ext:quit)))

#+end_src
*** core
**** Tangle to file block
#+name: core
#+header: :comments link
#+begin_src lisp :noweb yes :tangle ./core.lisp
(in-package :<<project-name-base()>>)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (rename-package :postmodern :postmodern '(psql)))
<<connection>>
<<queries>>
<<helpers>>
<<routes>>
#+end_src
**** Connection handling
https://www.mail-archive.com/postmodern-devel@common-lisp.net/msg00348.html
https://sites.google.com/site/sabraonthehill/postmodern-examples/postmodern-connections

#+name: connection
#+header: :comments link
#+begin_src lisp :noweb yes
#-(and)
(defparameter *db-connection* (postmodern:connect-toplevel
                               <<db-name>>
                               "<<user-name>>"
                               "TODO-pgpass"
                               "localhost"
                               :port 5432))

(defparameter *db-connection-parameters* '("<<db-name>>"
                                           "<<user-name>>"
                                           "gsu123"
                                           "localhost"
                                           :pooled-p t))

(defmacro with-connection (&body body)
  `(postmodern:with-connection *db-connection-parameters*
     ,@body))

(defvar *acceptor* nil)

(defun server-start (&key (port 4242) (log t))
  (server-stop)
  (hunchentoot:start (setf *acceptor*
                           (make-instance 'easy-routes:routes-acceptor
                                          :port port)))
  (unless log
    (setf (slot-value *acceptor* 'hunchentoot::access-log-destination) nil)
    (setf (slot-value *acceptor* 'hunchentoot::message-log-destination) nil)))

(defun server-stop ()
  (when *acceptor*
    (when (hunchentoot:started-p *acceptor*)
      (hunchentoot:stop *acceptor*))))

(defun format-git-id (first-commit &optional (ref ""))
  (format nil "Id: git:~a:~a" first-commit ref))

#+end_src
**** Queries
#+name: queries
#+begin_src lisp :results none
;;; queries

(defun query-insert-fc (first-commit git-remote)
  (handler-bind
      (
       (cl-postgres-error:unique-violation (lambda (condition)
                                             (declare (ignore condition))
                                             (print "aaaaaaaaaaa 1")
                                             ;;(abort-web 200)
                                             (setf (hunchentoot:return-code*) 200)
                                             ;;(invoke-restart 'continue)
                                             (ignore-errors)
                                             ;;(invoke-restart 'abort)
                                             (print "aaaaaaaaaaa 2")
                                             ))
       ;;(cl-postgres-error:unique-violation (lambda (condition) (abort-web 200)))
       ;;(error (lambda (condition) (print "argh") (print condition) (error condition)))
       )
    (with-connection
        (postmodern:query (:insert-rows-into 'first_commits
                           :columns 'first_commit 'git_remote
                           :values (list (list first-commit git-remote)))))))

;; TODO (handler-bind (cl-postgres-error::* #'some-handler))
(defun query-select-fc-remotes (first-commit)
  (with-connection
      (postmodern:query (:select 'git_remote
                         :from 'first_commits
                         :where (:= 'first_commit first-commit)))))

(defun query-select-id-remotes (first-commit &optional ref)
  ;; TODO
  (declare (ignore ref))
  (with-connection
      (query-select-fc-remotes first-commit)))

#+end_src
**** Helper functions
#+name: helpers
#+begin_src lisp :results none
;;; helpers

(defun abort-db (condition)
  ;; TODO
  (declare (ignore condition))
  (abort-web 500))

(defun abort-web (&optional code)
  (setf (hunchentoot:return-code*) code)
  (hunchentoot:abort-request-handler))

(defun parse-id (id)
  (destructuring-bind (&optional type first-commit ref)
      (uiop:split-string id :separator ":")
    (format *standard-output* "~s ~s ~s" type first-commit ref)
    (cond ((string= type "git")
           (if ref  ; implies first-commit
               (query-select-id-remotes first-commit ref)
               (if (and first-commit (not (string= first-commit "")))
                   (query-select-fc-remotes first-commit)
                   (abort-web 404))))
          (t (abort-web 404)))))
#+end_src
**** Routes
#+name: routes
#+begin_src lisp :results none
;;; routes
(easy-routes:defroute post-git-fc
    ("/git/:first-commit" :method :post) (remote)
  (setf (hunchentoot:content-type*) "text/plain")
  ;; if known remote pattern check for first commit
  ;; if config parameter set to check all clone and validate first commit
  ;; if everything checks out add remote and first commit to database
  (setf (hunchentoot:return-code*) 201)  ; 200 returns on unique constraint violation
  (ignore-errors  ; WHY DO WE HAVE TO USE THIS !?!?!!
  (query-insert-fc first-commit remote))
  ;; wow ... it just... works ...
  (format nil "Register: git:~a -> ~a" first-commit remote))

(easy-routes:defroute get-resolve-id
    ("/resolve/:id" :method :get) ()
  (print (hunchentoot:headers-in hunchentoot:*request*))
  (if nil
      (progn 
        (setf (hunchentoot:content-type*) "text/plain")
        (format nil "Id ~a -> ~a" id (parse-id id)))
      (progn
        (setf (hunchentoot:content-type*) "text/plain")
        (let ((remotes (parse-id id)))
          ;;(format t "remotes: ~a" remotes)
          (if remotes
              (caar remotes)  ; list of lists coming back from the query, which is bad
              (abort-web 404))))))

(easy-routes:defroute get-git-fc
    ("/git/:first-commit" :method :get) ()
  (setf (hunchentoot:content-type*) "text/plain")
  (let ((results (query-select-fc-remotes first-commit)))
    (format nil "Id: git:~a -> ~a" first-commit results)))

(easy-routes:defroute get-git-fc-ref
    ("/git/:first-commit/:ref" :method :get) ()
  (setf (hunchentoot:content-type*) "text/plain")
  (format-git-id first-commit ref))
#+end_src

# Just here to say that being able to C-x C-e the sexp and have
# the bug go away on the live server is really satisfying
*** test
**** cl
Use =dexador= as our http client.
#+begin_src lisp :results none
(ql:quickload :dexador)
#+end_src

#+begin_src lisp :results drawer
(dex:post (concatenate 'string
                       "http://localhost:4242/git/e6cf3a391686a0b49171b9b195da88e81125bb1e"
                       "?remote=https://github.com/tgbugs/git-share.git"))
#+end_src

#+RESULTS:
:results:
"Register: git:e6cf3a391686a0b49171b9b195da88e81125bb1e -> https://github.com/tgbugs/git-share.git"
200
#<HASH-TABLE :TEST EQUAL :COUNT 4 {1007F42E83}>
#<QURI.URI.HTTP:URI-HTTP http://localhost:4242/git/e6cf3a391686a0b49171b9b195da88e81125bb1e?remote=https://github.com/tgbugs/git-share.git>
#<SB-SYS:FD-STREAM for "socket 127.0.0.1:41104, peer: 127.0.0.1:4242" {1007F405E3}>
:end:

#+begin_src lisp :results drawer
(dex:get "http://localhost:4242/git/e6cf3a391686a0b49171b9b195da88e81125bb1e")
#+end_src

#+RESULTS:
:results:
"Id: git:e6cf3a391686a0b49171b9b195da88e81125bb1e -> ((git@github.com:tgbugs/git-share.git)
                                                     (https://github.com/tgbugs/git-share.git))"
200
#<HASH-TABLE :TEST EQUAL :COUNT 4 {1007B55C73}>
#<QURI.URI.HTTP:URI-HTTP http://localhost:4242/git/e6cf3a391686a0b49171b9b195da88e81125bb1e>
#<SB-SYS:FD-STREAM for "socket 127.0.0.1:41050, peer: 127.0.0.1:4242" {1007B534A3}>
:end:
**** bash/curl
#+begin_src bash
time for i in {0..9999}; do echo $i; done | \
xargs -P15 -r -n 1 -- curl -X GET http://localhost:4242/git/e6cf3a391686a0b49171b9b195da88e81125bb1e -H
#+end_src

|  time | avg       |
|-------+-----------|
|   6.8 | 6.8072857 |
|   6.7 | 1469.0143 |
| 6.542 |           |
| 7.323 |           |
| 7.045 | slad      |
| 6.306 |           |
| 6.935 | slad      |
#+TBLFM: @2$2=vmean(@2$1..@>$1)
#+TBLFM: @3$2=(10000 / @2$2)

**** queries
# TODO use =with-connection= instead
Run this in your repl if you are going to run these directly.
Might be able to unify =with-connection= and =query= for both
repl and server, aka swank and hunchentoot. As long as we don't
have multiple databases that we need to query within a single
namespace this should be ok.

#+name: connect-toplevel
#+begin_src lisp :noweb yes
(defparameter *db-connection*
  (postmodern:connect-toplevel
   "<<db-name>>"
   "<<user-name>>"
   "gsu123"
   "localhost"))
#+end_src

#+begin_src elisp :noweb yes :results drawer :wrap src lisp
(pp '
 <<connect-toplevel>>)
#+end_src

#+RESULTS:
#+begin_src lisp
(defparameter *db-connection*
  (postmodern:connect-toplevel "git_share_test" "git-share-user" "gsu123" "localhost"))
#+end_src


#+begin_src lisp
(postmodern:query (:select '* :from 'first_commits))
#+end_src

#+begin_src lisp
(postmodern:query "INSERT INTO first_commits (first_commit, git_remote)
                    VALUES ('6d96945e85d4e949215910f13f3e620495b5e165',
                            'https://github.com/tgbugs/pyontutils.git')")
#+end_src

** bash
NOTE there can be more than one first commit
#+begin_src bash
function git-share-first-commit () {
    FC=$(git rev-list --max-parents=0 HEAD)
    for remote in $(git remote get-url --all origin); do
        curl -X POST "http://localhost:4242/git/${FC}?remote=${remote}"
    done
    # TODO always push to the local git-share instance first (sigh c)
    # and that will then deal with connecting to federated servers
}
function git-share-all () {
    git remote get-url --all origin
}
# git-share-first-commit
# git-share-all
#+end_src

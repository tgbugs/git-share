# -*- orgstrap-cypher: sha256; orgstrap-norm-func-name: orgstrap-norm-func--prp-1\.1; orgstrap-block-checksum: 85ede7c187eeefc6adc8bdcdef347d11162665416861fef60d04a20d91ef6599; -*-
# [[orgstrap][jump to the orgstrap block for this file]]
#+TITLE: git-share a git repository resolver

# FIXME this needs to be called before tangling can continue ... how safely ...
#+call: def-project-name-base() :var reset=(identity nil)

#+name: project-description-short
#+header: :results value drawer
#+begin_src elisp :exports results :eval no-export
"A git repository registration service and resolver."
#+end_src

#+RESULTS: project-description-short
:results:
A git repository registration service and resolver.
:end:

* Setup
To get started tangle this file. Yes the double tangle is intentional.
# In [[../sparc-curation/docs/setup.org::tangle-setup-org]] I have nearly
# figured out the way to handle the double bootstrap succeed when there are
# unbound elisp functions, it requires the use of fboundp.
#+begin_src bash :eval never :exports code
emacs --batch \
      --load org \
      --load ob-shell \
      --eval "(unless ((lambda (a b) (or (string> a b) (string= a b))) (org-version) \"9.3\") (message (format \"your org is too old! %s < 9.3 try loading ~/git/orgstrap/init.el\" (org-version))) (kill-emacs 1))" \
      --eval "(org-babel-tangle-file \"README.org\")" \
      --load org-elisp-setup-hack.el \
      --eval "(org-babel-tangle-file \"README.org\")" &&
rm org-elisp-setup-hack.el
#+end_src
** Dependencies
Git share uses the =pguri= extension. On Gentoo you can install it with the following.

#+begin_src bash
layman -a tgbugs-overlay
emerge pguri
#+end_src
** Quicklisp
TODO
* Background
What if I could run =git share= in a repository to tell the world that I had a copy of a
git repository available somewhere? Using the first commit hash of a repo as a unique ID
for that repository (multi-parent aside) resolution to individual copies is the achieved
via a many-to-one mapping from the first commit hash to registered remotes.

=git share --all= could also automatically include all remotes in a =.git/config= as well.

Ids like =git:e6cf3a391686a0b49171b9b195da88e81125bb1e= can be resolved directly,
but there are no guarantees that the target repo will be up to date.

Using this mapping, a PID like
=git:e6cf3a391686a0b49171b9b195da88e81125bb1e:e6cf3a391686a0b49171b9b195da88e81125bb1e=
can be resolved easily if registered remotes have native support for commit resolution,
or at the very least can respond yes or to the question "Do you have a commit with this
hash?" In theory multiple sites could run instrumented repositories to enable this, and
in theory a registry could store the trees of hashes up to the point when =git share= is
run, perhaps as =git share --trees=.

The behavior of =share= could be configured as part of the global git config, of greatest
interest would be configuring which registries to use.

Automated metadata extraction to construct persistable metadata from a git repository is
another potential part of this. One complaint about using bare git hashes is that there
isn't any metadata associated with them to provide context for/information about their
referent. In many cases this could be automatically extracted to provide more 'PIDness'
for the pure hash identifiers.

* Design
** issues
Validation that the remote's first commit matches the asserted value is important.
If there is a trusted process that is making the submissions that would work as well.
You could pretty much have a giant batch of crawlers for these since there isn't really
a need to keep the data around, clone the repo and find the parentless commits for all
heads, submit/validate the entry in the database, and then rm the repo and go get the next one.

If using =git-share= in a local agent configuration (not yet implemented) then this
is less relevant since the crawler and the submitter are essentially the same. When
coordinating between nodes run by individuals we will have to deal with the validation and
verification issue as well.

If it turns out that something like this is useful, it might make sense to try to get
it implemented as part of the stock information that remote git repos can answer without
having to get the whole repo.
** endpoints
*** =/sexp=
port 80 endpoint that accepts sexps and nothing else
no http semantics at all
#+begin_src lisp :eval never
(git first-commit-hash ref)
#+end_src
*** =/repo=
**** =/repo/=
**** =/repo/submit=
**** =/resolve=
**** =/resolve/{first-commit}=
**** =/resolve/{first-commit}/{ref}=
in theory we can resolve shortened fragments until things become ambiguous
**** =/resolve?first-commit={first-commit}&ref={ref}=
**** =/git=
**** =/git/{first-commit}=
**** =/git/{first-commit}/{ref}=
in theory we can resolve shortened fragments until things become ambiguous
**** =/git?first-commit={first-commit}&ref={ref}=
** Using git config to seed remote providers
https://github.com/magit/orgit#export
org-babel-exp-do-export
* Code
#+name: project-name-base
: git-share

# sigh, inconsistency between eval, tangle, and export
#+name: project-name-safe
: git_share

** elisp
#+name: def-project-name-base
#+header: :noweb yes :results value :cache yes :lexical yes
#+begin_src emacs-lisp :exports none :var reset=(identity nil)
(when (or (not (boundp '--git-share-elisp-loaded)) (and (boundp 'reset) reset))
(defvar *-gsell-* t)
(defun project-name (&optional suffix)
  "project name without - separator"
  (format "%s%s" "<<project-name-base()>>" (or suffix "")))
(defun project-name-base (suffix)
  (format "%s-%s" "<<project-name-base()>>" suffix))
(defun format-safe (string)
  (replace-regexp-in-string
    (regexp-quote "-")
    "_"
    string
    nil 'literal))
(defun project-db-name ()
  "<<db-name>>")
(setq --git-share-elisp-loaded (if (and (boundp 'reset) reset) (current-time-string) t)))
#+end_src
** SQL
:PROPERTIES:
:header-args:sql: :mkdirp yes
:END:
*** vars
# :eval never is a hack around bad tangle behavior
#+name: schema-name
#+begin_src org :noweb yes
<<project-name-safe()>>
#+end_src

#+name: admin-name
#+begin_src org :noweb yes
<<project-name-base()>>-admin
#+end_src

#+name: user-name
#+begin_src org :noweb yes
<<project-name-base()>>-user
#+end_src

# TODO Change this for production, and/or find a way to branch without export pain.
#+name: db-name
#+begin_src org :noweb yes
<<project-name-safe()>>_test
#+end_src

*** code
:PROPERTIES:
:CREATED:  [2020-01-29 Wed 16:51]
:header-args: :comments link
:END:
**** database and role creation
#+name: postgres
#+header: :engine postgresql
#+header: :dbhost localhost
#+header: :dbuser postgres
#+header: :database postgres
#+header: :cmdline (when (boundp '*-gsell-*) (format "-v database=%s" (project-db-name)))
#+begin_src sql :noweb yes :tangle (when (boundp '*-gsell-*) "./sql/postgres.sql")
DO
$body$
BEGIN
    IF NOT EXISTS ( SELECT * FROM pg_catalog.pg_user
        WHERE usename = '<<user-name>>') THEN
        CREATE ROLE "<<user-name>>" LOGIN
        NOSUPERUSER INHERIT NOCREATEDB NOCREATEROLE;
    END IF;
    IF NOT EXISTS ( SELECT * FROM pg_catalog.pg_user
        WHERE usename = '<<admin-name>>') THEN
        CREATE ROLE "<<admin-name>>" LOGIN
        NOSUPERUSER INHERIT NOCREATEDB NOCREATEROLE;
    END IF;
END;
$body$ language plpgsql;

ALTER ROLE "<<admin-name>>" SET search_path = <<schema-name>>, public;
ALTER ROLE "<<user-name>>" SET search_path = <<schema-name>>, public;

DROP DATABASE IF EXISTS :database;

CREATE DATABASE :database
    WITH OWNER = '<<admin-name>>'
    ENCODING = 'UTF8'
    TABLESPACE = pg_default
    LC_COLLATE = 'en_US.UTF-8'  -- this was a gentoo locale issue check ${LANG}
    LC_CTYPE = 'en_US.UTF-8'
    CONNECTION LIMIT = -1;
#+end_src
**** role passwords
The first time only set passwords and put them in [[file:~/.pgpass]].
This requires interactive session, e.g. via =M-x sql-postgres=.
The [[psql-interactive][psql-interactive]] block below this example will
launch the appropriate interactive session to set the passwords. Your user
will need to have permission to login as =postgres= or you need to have set
the postgres password in [[file:~/.pgpass]] e.g. via a line like
=localhost:5432:*:postgres:the-pg-p4ssw0rd=.

#+header: :dbuser postgres
#+header: :database postgres
#+begin_src sql :noweb yes :eval never
\password '<<admin-name>>'
\password '<<user-name>>'
\quit
#+end_src

#+name: psql-interactive
#+header: :results silent
#+begin_src elisp :eval no-export :var this-org-buffer=(buffer-name (current-buffer))
;; required to get the expected behavior when setting passwords
;; otherwise the second prompt "Enter it again:" fails to match
(when (not (string-match "it\\\\\|Response" comint-password-prompt-regexp))
  (setq comint-password-prompt-regexp
        (let ((sl (split-string comint-password-prompt-regexp "Response")))
          (concat (car sl) "it\\|Response" (cadr sl)))))

;; TODO this doesn't work due to how orb babel calls elisp NOT due to buffer confusion
;; https://emacs.stackexchange.com/questions/42096/running-elisp-within-an-orgmode-code-block
(let* ((sql-postgres-login-params
        '((user :default "postgres")
          (database :default "postgres")
          (server :default "localhost")
          (port :default 54321)))
       (buffer (sql-postgres)))
  (with-current-buffer (get-buffer this-org-buffer)
    (split-window-below)
    (windmove-down)
    (switch-to-buffer buffer)))
#+end_src
**** extensions
#+name: extensions
#+header: :engine postgresql
#+header: :dbhost localhost
#+header: :dbuser postgres
#+header: :database (when (boundp '*-gsell-*) (project-db-name))
#+begin_src sql :noweb yes :tangle (when (boundp '*-gsell-*) "./sql/extensions.sql")
CREATE EXTENSION uri;
CREATE EXTENSION pgcrypto;
#+end_src
**** schemas
#+name: schemas
#+header: :engine postgresql
#+header: :dbhost localhost
#+header: :dbuser (when (boundp '*-gsell-*) (project-name-base "admin"))
#+header: :database (when (boundp '*-gsell-*) (project-db-name))
#+begin_src sql :noweb yes :tangle (when (boundp '*-gsell-*) "./sql/schemas.sql")
CREATE SCHEMA IF NOT EXISTS <<schema-name>>;
#+end_src
**** tables
#+name: tables
#+header: :engine postgresql
#+header: :dbhost localhost
#+header: :dbuser (when (boundp '*-gsell-*) (project-name-base "admin"))
#+header: :database (when (boundp '*-gsell-*) (project-db-name))
#+begin_src sql :noweb yes :tangle (when (boundp '*-gsell-*) "./sql/tables.sql")
-- wrap table creation in a transaction block to avoid partial failures along the way
-- from resulting in future failures when tables already exist
DO
$body$
BEGIN

CREATE TABLE first_commits(
       first_commit char(40) NOT NULL,
       -- git_remote_uri uri NOT NULL -- FIXME git@github.com:tgbugs/git-share.git breaks this
       git_remote text NOT NULL,
       remote_provider_id integer,
       CONSTRAINT pk__first_commits PRIMARY KEY (first_commit, git_remote),
       CONSTRAINT fk__first_commits__git_remote_provider__remote_providers__id
                  FOREIGN KEY (remote_provider_id)
                  REFERENCES remote_providers (id) match simple
);

CREATE TABLE remote_providers(
       id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
       name text NOT NULL,
       pattern_human,
       pattern_machine,
);

CREATE TABLE remote_trees(
       git_remote text NOT NULL
       -- tree NOT NULL -- TODO
);

CREATE TYPE mirror_type AS enum ('all', 'first-commits', 'none');
CREATE TYPE mirror_mode_type AS enum ('push', 'pull', 'both');

CREATE TABLE registries(
       uri text NOT NULL,
       last_contact timestamp NOT NULL,
       mirror mirror_type NOT NULL,
       mode mirror_mode_type NOT NULL
);

END;
$body$ language plpgsql;
#+end_src
**** permissions
#+name: permissions
#+header: :engine   postgresql
#+header: :dbhost   localhost
#+header: :dbuser   (when (boundp '*-gsell-*) (project-name-base "admin"))
#+header: :database (when (boundp '*-gsell-*) (project-db-name))
#+header: :cmdline  (when (boundp '*-gsell-*) (format "-v database=%s" (project-db-name)))
#+begin_src sql :noweb yes :tangle (when (boundp '*-gsell-*) "./sql/permissions.sql")
GRANT CONNECT
   ON DATABASE :database
   TO "<<user-name>>";

GRANT USAGE
   ON SCHEMA <<schema-name>>
   TO "<<user-name>>";

GRANT SELECT, INSERT
   ON ALL TABLES IN SCHEMA <<schema-name>>
   TO "<<user-name>>";  -- tables includes views

GRANT USAGE
   ON ALL SEQUENCES IN SCHEMA <<schema-name>>
   TO "<<user-name>>";

GRANT INSERT (first_commit, git_remote)
   ON <<schema-name>>.first_commits
   TO "<<user-name>>";
#+end_src

# annoyingly these call blocks all fail with weird bash errors
# because things like (project-db-name) are not evaluated first
# #+call: postgres()
# #+call: extensions()
# #+call: schemas()
# #+call: tables()
# #+call: permissions()

#+header: :shebang "#!/usr/bin/env bash" :mkdirp yes
#+begin_src bash :noweb yes :tangle (when (boundp '*-gsell-*) (format "./bin/%s" (project-name-base "db-setup")))
# TODO sadly this is easier to do in bash
#+end_src

** cl
:properties:
:header-args: :comments link
:end:
# sadly the force eval hack doesn't work
# because org looks for the project-name-* functions first
# :var --force-eval-hack=def-project-name-base()
# :header-args: :comments link :var __FORCE_EVAL_HACK=def-project-name-base()
*** common
#+name: quicklisp-setup
#+begin_src lisp
#-quicklisp
(let ((quicklisp-init (merge-pathnames "code/lisp/quicklisp/setup.lisp"
                                       (user-homedir-pathname))))
  (when (probe-file quicklisp-init)
    (load quicklisp-init)))
#+end_src
*** packages
#+name: package.lisp
#+begin_src lisp :noweb yes :tangle ./src/package.lisp :mkdirp yes
(in-package :cl-user)

(defpackage #:<<project-name-base()>>
  (:use :cl)
  (:export #:server-start
           #:server-stop))

(defpackage #:parse-args
  (:use :cl)
  (:export #:parse-args))

,#+()
(defpackage #:<<project-name-base()>>/daemon
  (:use
   #:cl
   #:<<project-name-base()>>
   ; reminder that deps do not go in :use
   ;#:cl-daemonize
   ;#:swank
))
#+end_src

#+name: project-asd
#+header: :eval never
#+begin_src lisp :noweb yes :tangle (when (boundp '*-gsell-*) (format "./%s" (project-name ".asd")))
(in-package :cl-user)
(defpackage :<<project-name-base()>>-asd
            (:use #:cl #:asdf))
(in-package :<<project-name-base()>>-asd)

(defsystem :<<project-name-base()>>
  :version "0.0.1"
  :author "Tom Gillespie <tgbugs@gmail.com>"
  :license "GPL2"  ; match the git license need to check compat with other things here
  :description <<project-description-short>>
  :depends-on ("cl-interpol"
               "cl-who"
               "easy-routes"
               "hunchentoot"
               "named-readtables"
               "postmodern")
  :components ((:module "src"
                :serial t  ; needed so that package loads before the others
                :components ((:file "package")
                             (:file "core")
                             (:file "parse-args")))))

,#+()
(defsystem :<<project-name-base()>>/daemon
  :depends-on (:<<project-name-base()>>
               "cl-daemonize"
               "swank")
  ;;:components ((:file "daemon"))  ; explicitly don't load the file since it is a script
  )

(defsystem :<<project-name-base()>>/start-small
  :depends-on (:<<project-name-base()>>
               "swank"))

(defsystem :<<project-name-base()>>/bootstrap-image
  :depends-on (:<<project-name-base()>>
               #:swank)
  :components ((:module "src"
                :components ((:file "bootstrap-image")))))

(defsystem :<<project-name-base()>>/test
  :depends-on (:<<project-name-base()>>)
  :components ((:module "test"
                :serial t
                :components ((:file "package")
                             (:file "tests")))))
#+end_src
*** parse args
#+name: parse-args-cli
#+begin_src lisp :tangle ./src/parse-args.lisp :mkdirp yes
(in-package :parse-args)

(defun norm-arg (arg)
  ; FIXME type decls here would help
  ; FIXME parse-integer ignores leading zeros!
  (let ((int (ignore-errors (parse-integer arg))))
    (if int int arg)))

(defun process-keyword (element)
  (when (not (listp element))
    (error (format nil "~s not a list!" element)))
  (let* ((kw (car element))
         (sl (string-downcase (symbol-name kw)))
         (assign (cdr element))  ; FIXME default? FIXME XXX empty vs explicit nil
         ;;(real-assign (if assign (car assign) (intern (symbol-name kw))))
         (real-assign (intern (symbol-name kw)))
         (default (if assign (car assign) assign)) ; FIXME
         (p (if assign
                `(progn (setf ,real-assign (norm-arg (cadr args)))
                        ;; equivalent of bash shift shift
                        (setf args (cddr args)))
                `(progn (setf ,real-assign t)
                        ;; equivalent of bash shift
                        (setf args (cdr args))))))
    (list `(,real-assign ,default)  ; default
          `(,(intern (format nil "--~a" sl)) ,p)  ; case
          `(cons ',real-assign ,real-assign))))

(defmacro parse-args (&body keywords)
  "(parse-args (:port port) (:pid pid) (:flag))

   NOTE if the default value if a kwarg is nil rather than
   empty i.e. (:asdf nil) vs (:asdf) the form with nil will
   not fail but will be nil unless some value is provided
   AND it will eat the next kwarg this is probably a misdesign"
  ;;(print (apply #'mapcar #'list (map 'list #'pk keywords)))
  ;;(format *standard-output* "~s~%" keywords)
  ;;`(,@keywords)
  `(quote ,keywords)
  (destructuring-bind (defaults cases returns)
      (apply #'mapcar #'list (map 'list #'process-keyword keywords))
    `(let ((args (cdr (uiop:raw-command-line-arguments)))
           ,@defaults)
       (do ()
           ((null args) nil)
         (case (intern (car args))
           ,@cases
           (otherwise (progn (format *standard-output* "unhandled: ~s~%" (car args))
                             (setf args (cdr args))))))
       (list ,@returns))))
#+end_src
**** test
While we're here, some crazy stuff on shebangs.
<https://stackoverflow.com/questions/4303128/
how-to-use-multiple-arguments-for-awk-with-a-shebang-i-e>

#+header: :shebang "#!/usr/bin/env -S sbcl --script" :tangle-mode (identity #o0755)
#+begin_src lisp :noweb yes :tangle ./test/args-test :results output :mkdirp yes
<<quicklisp-setup>>
<<package.lisp>>
<<parse-args-cli>>
(format *standard-output* "~s~%" sb-ext:*posix-argv*)
(format *standard-output* "~s~%" (parse-args (:qq nil)
                                             (:port 4242)
                                             (:pid "/tmp/<<project-name-base()>>.pid")
                                             (:flag)))
(format t "~s~%" *compile-file-truename*)
(format t "~s~%" *compile-file-pathname*)
#+()
(print (macroexpand '(parse-args (:flag) (:asdf 123))))
#+end_src

#+header: :shebang "#!/usr/bin/env -S ecl -q --norc --shell" :mkdirp yes
#+begin_src lisp :noweb yes :tangle ./test/args-test-ecl :results output
<<quicklisp-setup>>
<<package.lisp>>
<<parse-args-cli>>
(format *standard-output* "~s~%" (loop for n from 0 below (si:argc) collect (si:argv n)))
(format *standard-output* "~s~%" (parse-args (:qq nil)
                                             (:port 4242)
                                             (:pid "/tmp/<<project-name-base()>>.pid")
                                             (:flag)))
(format t "~s~%" *compile-file-truename*)
(format t "~s~%" *compile-file-pathname*)
#+()
(print (macroexpand '(parse-args (:flag) (:asdf 123))))
#+end_src

#+begin_src lisp :exports none :eval never
'
(let ((args (cdr sb-ext:*posix-argv*))
      (port 4242)
      (pid  "/run/asdf/pid"))

  (do ()
      ((null args) nil)
    (case (intern (car args))
      (|--port| (progn (setq port (cadr args))
                       (setq args (cddr args))))
      (|--pid| (progn (setq pid (cadr args))
                      (setq args (cddr args))))
      (otherwise (progn (format *standard-output* "unhandled: ~s~%" (car args))
                        (setq args (cdr args))))))
  (print (list port pid)))
#+end_src
*** development
**** slime
# FIXME probably better to use asdf:load-system
# even in this context ...
#+name: slime-repl-setup
#+begin_src lisp
(ql:quickload :cl-interpol)
(ql:quickload :cl-who)
(ql:quickload :easy-routes)
(ql:quickload :hunchentoot)
(ql:quickload :named-readtables)
(ql:quickload :postmodern)
(rename-package :postmodern :postmodern '(psql))
(defpackage #:git-share
  (:use :cl)
  (:export #:server-start
           #:server-stop))
#+end_src

#+name: slime-repl-devel
#+caption: run this block if you are going to be doing interactive development in the repl
#+header: :comments link :results none
#+begin_src lisp :noweb yes
(setq hunchentoot:*catch-errors-p* nil)
<<core>>
(git-share:server-start :port 4242)
#+end_src

When you are done you can run the following block.
#+name: slime-repl-devel-stop
#+begin_src lisp
(git-share:server-stop)
#+end_src

For whatever reason we still need ref:slime-repl-setup.
I still have no idea how to get org-bable to execute the quickload
bits first and the rest later if it is all sent in one block. Also
the first time loading these it can make more sense to execute them
manually so that you get an interactive debugging session in the event
that something goes wrong.

The ref:slime-repl-devel block only needs to be run once, after that any
further modifications can be made by executing the ref:core or any of
the other blocks block again without needing to run this block again.

Also apparently if we don't do testing in =cl-user= or something like that then
there is a problem finding the database connection? Pretty sure that is a bug on my end.

# Hrm, maybe the issue is that I need to add an eval-when compile to the quickloads?
# yes it would seem so, but then there is the issue that if you run this in the same
# emacs client you are clicking an org-link from you have to C-g out of the org link
# resolution code in order to debug in slime. Sigh async emacs.

*** deployment
**** SLaD
So. Of all the many ways that one can try to package this thing to run
this is the one that amuses me the most deeply. 15mb. Sure you need a
copy of sbcl on the server, but still ... wow.

Tangle and run build-image to create a core dump that can be loaded on another system.

And WOW the memory savings compared to running the =start-small= version.
Obviously a tradeoff in there somewhere, but seriously wow.

# FIXME final executable location should be ./bin
# #+header: :var project-path=(identity default-directory)
#+name: build-image-sbcl
#+header: :shebang "#!/usr/bin/env -S sbcl --script"
#+begin_src lisp :noweb yes :tangle ./bin/build-image-sbcl :mkdirp yes
<<quicklisp-setup>>
(push (uiop:truenamize #p"~/git/<<project-name-base()>>") ql:*local-project-directories*)
(ql:quickload :<<project-name-base()>>/bootstrap-image)
(save-lisp-and-die "bin/git-share-sbcl" :toplevel #'main :executable t :compression t)
#+end_src

#+name: bootstrap-common
#+begin_src lisp :noweb yes :tangle ./src/bootstrap-image.lisp
(defparameter *finished* nil)

(defun main ()
  (format t "~s~%" (uiop:raw-command-line-arguments))
  (let* ((args (parse-args:parse-args
                 (:port 4242)
                 (:pid #p"/tmp/<<project-name-base()>>.pid") ; FIXME not portable and dangerous
                 (:port-swank 4006)
                 (:debug)))
         (*port* (cdr (assoc 'port args)))
         (*path-pid* (cdr (assoc 'pid args)))
         (*port-swank* (cdr (assoc 'port-swank args)))
         (*debug* (cdr (assoc 'debug args))))
    (when *debug*
      (setq hunchentoot:*catch-errors-p* nil) ; doesn't seem to be working
      (enable-debugger))
    (swank:create-server :port *port-swank*)
    (git-share:server-start :port *port*))

  (format t "STARTED~%")
  (loop :do
    (sleep 5)
    (when *finished*
      (format t "DONE~%")
      (git-share:server-stop)
      (uiop:quit))))
#+end_src

It seems like =app-misc/detachtty= may be needed to get this to work.
Or the eternal loop might work as well. Needs more testing.

#+name: open-rc-init-script-slad
#+header: :mkdirp yes
#+begin_src bash :tangle ./resources/file-system/etc/init.d/git-share-slad.rc
#!/sbin/openrc-run
# Copyright 1999-2020 Gentoo Authors
# Distributed under the terms of the GNU General Public License v2

: ${LOG_LEVEL:=info}
: ${SVCGROUP:=git-share}
: ${SVCUSER:=git-share}
: ${LOG_LOC:="/var/log/git-share"}

run_dir=${run_dir:-/run}
LOG="${LOG_LOC}/sysout.log"

pidfile="${run_dir}/${SVCNAME}/pid"
start_stop_daemon_args="
--group ${SVCGROUP}
--user ${SVCUSER}
--wait 1000
--env DOWENEEDENV=${SOMEENV}
"
command="/usr/bin/sbcl"
command_args="--port ${PORT}
--port-swank ${PORT_SWANK}"
retry='TERM/30/KILL/5'

command_owner="${SVCUSER}:${SVCGROUP}"

depend() {
    after net
}

start_pre() {
    local OOPS=0
    if [[ "${HRM_API}" == *"some-value"* ]] && [ -z "${HRM_KEY}" ]; then
        eend 1 durn
        OOPS=1
    fi
    if [ ${OOPS} -ne 0 ]; then
        return 1
    fi
    checkpath --directory --owner ${command_owner} --mode 0775 "/run/${SVCNAME}"
    checkpath --directory --owner ${command_owner} --mode 0775 "${LOG_LOC}"
}
#+end_src
**** foreground
Maybe a smaller version that uses openrc instead of self daemonizing
to be a bit friendly/more interoperable with posix conventions?
http://theatticlight.net/posts/A-Lisp-Daemon/
https://www.darkchestnut.com/2016/daemonizing-common-lisp-services/
https://www.reddit.com/r/Common_Lisp/comments/4n7ly6/daemonizing_common_lisp_services/

#+name: start-small
#+header: :shebang "#!/usr/bin/sbcl --script"
#+header: :tangle-mode (identity #o0755)
#+begin_src lisp :noweb yes :tangle ./start-small.lisp
<<quicklisp-setup>>
(push (uiop:truenamize #p"~/git/<<project-name-base()>>") ql:*local-project-directories*)
(ql:quickload :<<project-name-base()>>/start-small)

<<parse-args-cli>>

(let ((args (parse-args (:port 4242)
                        (:pid #p"/tmp/<<project-name-base()>>.pid")
                        ;; FIXME apparently can't log into the git folder or something !?
                        ;;(:path-log-out #p"/tmp/debug-out.log")
                        ;;(:path-log-err #p"/tmp/debug-err.log")
                        ;; log to sysout in daemon for this one
                        )))
  (defparameter *port* (cdr (assoc 'port args)))
  (defparameter *path-pid* (cdr (assoc 'pid args)))
  (defparameter *path-log-out* (cdr (assoc 'path-log-out args)))
  (defparameter *path-log-err* (cdr (assoc 'path-log-err args))))

(defparameter *finished* nil)

(swank:create-server :port 4006)
(git-share:server-start :port *port*)

(format *standard-output* "STARTED~%")
(loop :do
     (sleep 5)
     (when *finished*
       (format *standard-output* "DONE~%")
       (git-share:server-stop)
       (sb-ext:quit)))
#+end_src

#+name: open-rc-init-script
#+header: :mkdirp yes
#+begin_src bash :tangle ./resources/file-system/etc/init.d/git-share.rc
#!/sbin/openrc-run
# Copyright 1999-2020 Gentoo Authors
# Distributed under the terms of the GNU General Public License v2

: ${LOG_LEVEL:=info}
: ${SVCGROUP:=git-share}
: ${SVCUSER:=git-share}
: ${LOG_LOC:="/var/log/git-share"}

run_dir=${run_dir:-/run}
LOG="${LOG_LOC}/${SVCNAME}.log"

socket="unix:/run/${SVCNAME}/socket"

pidfile="${run_dir}/${SVCNAME}/pid"
start_stop_daemon_args="
--group ${SVCGROUP}
--user ${SVCUSER}
--wait 1000
--env DOWENEEDENV=${SOMEENV}
"
command="/usr/bin/sbcl"
command_args="--bind ${socket}
--port ${PORT}
--pid ${pidfile}"
retry='TERM/30/KILL/5'

command_owner="${SVCUSER}:${SVCGROUP}"

depend() {
    after net
}

start_pre() {
    OOPS=0
    if [ -z "${SCIGRAPH_API}" ]; then
        eend 1 "SCIGRAPH_API is not set in /etc/conf.d/${SVCNAME}"
        OOPS=1
    fi
    if [[ "${SCIRGRAPH_API}" == *"scicrunch"* ]] && [ -z "${SCIGRAPH_API_KEY}" ]; then
        eend 1 "SCIGRAPH_API requires SCIGRAPH_API_KEY not set in /etc/conf.d/${SVCNAME}"
        OOPS=1
    fi
    if [ ${OOPS} -ne 0 ]; then
        return 1
    fi
    checkpath --directory --owner ${command_owner} --mode 0775 "/run/${SVCNAME}"
    checkpath --directory --owner ${command_owner} --mode 0775 "${LOG_LOC}"
}
#+end_src
**** ecl
The best reference for this is
<https://common-lisp.net/project/ecl/static/manual/
System-building.html#Compiling-with-ECL> and the =asdf:make-build=
option seems to be the best for our use case.

# https://github.com/earl-ducaine/stupid-ecl-tricks-1#embedding-swank-in-a-c-application
# https://stackoverflow.com/questions/48103501/deploying-common-lisp-web-applications
# https://www.reddit.com/r/Common_Lisp/comments/hicmyt

I think in order to do this correctly I have to clone swank or get a copy of
the swank files and then create a new asd file with defsystems for the specific
files that need to be included in the image. The reason for this is that the
upstream swank asd file only includes the swank loader and does not include
any of the other parts of the system because the loader takes care of them.
However this causes problems when compiling with asdf:make-build since the
compiler has no idea that those files are needed.

# a good reference for shebangs https://www.cliki.net/Unix%20shell%20scripting
# #+header: :tangle-mode (identity #o0755)
#+name: build-image-ecl
#+header: :shebang "#!/usr/bin/env -S ecl -q --norc --shell"
#+begin_src lisp :noweb yes :tangle ./bin/build-image-ecl :mkdirp yes
,#+()
(eval-when (:compile-toplevel :load-toplevel :execute)
  (format t "aaaaaaaaaaaaaaaaaaa~%")
  ;;(load "/usr/lib64/ecl-20.4.24/ecl-quicklisp.fas")
  (load "/usr/lib64/ecl-20.4.24/asdf.fas"))
<<quicklisp-setup>>
(push (uiop:truenamize #p"~/git/<<project-name-base()>>") asdf:*central-registry*)
(asdf:make-build :git-share/bootstrap-image
                 :type :program
                 :monolithic t
                 :move-here #P"./"
                 ;;:prologue-code '(require :swank)
                 :epilogue-code '(main))
;; note that :overwrite has slightly different semantics and I'm not
;; I'm not entirely sure which one makes more sense in this context
;; nor what the exact differences in semantics are across implementations
(rename-file #p"./bootstrap-image" #p"./bin/git-share-ecl" :if-exists :supersede)
#+end_src

#+begin_src lisp
#+ecl
(progn
(require 'cmp)
(c:build-program "somewhere-else" "test-ecl.lisp")
)
#+end_src
**** daemon :old:
self daemonizing approach
#+header: :shebang "#!/usr/bin/sbcl --script"
#+header: :tangle-mode (identity #o0755)
#+begin_src lisp :noweb yes :tangle ./daemon.lisp
<<quicklisp-setup>>
;(require 'uiop)
;(require 'asdf)

(push (uiop:truenamize #p"~/git/NOFORK/cl-daemonize") ql:*local-project-directories*)
(push (uiop:truenamize #p"~/git/<<project-name-base()>>") ql:*local-project-directories*)
(ql:quickload :<<project-name-base()>>/daemon)
;(ql:quickload :<<project-name-base()>>)
;(ql:quickload '(cl-daemonize swank))
;(push (uiop:truenamize #p"~/git/<<project-name-base()>>") asdf:*central-registry*)
;(asdf:load-system :<<project-name-base()>>/daemon)  ; fixme recursion surely

;(load (uiop:truenamize "~/.emacs.d/elpa/slime-20191224.2328/swank-loader.lisp"))

(in-package :<<project-name-base()>>/daemon)

(defparameter *finished* nil)

<<parse-args-cli>>

(let ((args (parse-args (:port 4242)
                        (:pid #p"/tmp/<<project-name-base()>>.pid")
                        ;; FIXME apparently can't log into the git folder or something !?
                        (:path-log-out #p"/tmp/debug-out.log")
                        (:path-log-err #p"/tmp/debug-err.log"))))
     (defparameter *port* (cdr (assoc 'port args)))
     (defparameter *path-pid* (cdr (assoc 'pid args)))
     (defparameter *path-log-out* (cdr (assoc 'path-log-out args)))
     (defparameter *path-log-err* (cdr (assoc 'path-log-err args)))
)

(format *error-output* "~a ~a~%" *port* *path-pid*)
(format *standard-output* "~a ~a~%" *port* *path-pid*)

(cl-daemonize:daemonize :out *path-log-out* ;"output.log"
                        :err *path-log-err* ;"error.log"
                        :pid *path-pid*
                        :stop (lambda (&rest args)
                                (declare (ignore args))
                                (setf *finished* t)))

;(swank-loader:init)
(swank:create-server :port 4006)
(git-share:server-start :port *port*)

(format *standard-output* "STARTED~%")
(loop :do
     (sleep 1)
     (when *finished*
       (format *standard-output* "DONE~%")
       (git-share:server-stop)
       (sb-ext:quit)))

#+end_src
*** core
**** Tangle to file block
#+name: core
#+header: :comments link
#+begin_src lisp :noweb yes :tangle ./src/core.lisp
(in-package :<<project-name-base()>>)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (rename-package :postmodern :postmodern '(psql)))
<<connection>>
<<queries>>
<<helpers>>
<<routes>>
#+end_src
**** Connection handling
https://www.mail-archive.com/postmodern-devel@common-lisp.net/msg00348.html
https://sites.google.com/site/sabraonthehill/postmodern-examples/postmodern-connections

#+name: connection
#+header: :comments link
#+begin_src lisp :noweb yes
#-(and)
(defparameter *db-connection* (postmodern:connect-toplevel
                               <<db-name>>
                               "<<user-name>>"
                               "TODO-pgpass"
                               "localhost"
                               :port 5432))

(defparameter *db-connection-parameters* '("<<db-name>>"
                                           "<<user-name>>"
                                           "gsu123"
                                           "localhost"
                                           :pooled-p t))

(defmacro with-connection (&body body)
  `(postmodern:with-connection *db-connection-parameters*
     ,@body))

(defvar *acceptor* nil)

(defun server-start (&key (port 4242) (log t))
  (server-stop)
  (hunchentoot:start (setf *acceptor*
                           (make-instance 'easy-routes:routes-acceptor
                                          :port port)))
  (unless log
    (setf (slot-value *acceptor* 'hunchentoot::access-log-destination) nil)
    (setf (slot-value *acceptor* 'hunchentoot::message-log-destination) nil)))

(defun server-stop ()
  (when *acceptor*
    (when (hunchentoot:started-p *acceptor*)
      (hunchentoot:stop *acceptor*))))

(defun format-git-id (first-commit &optional (ref ""))
  (format nil "Id: git:~a:~a" first-commit ref))

#+end_src
**** Queries
#+name: queries
#+begin_src lisp :results none
;;; queries

(defun query-insert-fc (first-commit git-remote)
  (handler-bind
      (
       (cl-postgres-error:unique-violation (lambda (condition)
                                             (declare (ignore condition))
                                             (print "aaaaaaaaaaa 1")
                                             ;;(abort-web 200)
                                             (setf (hunchentoot:return-code*) 200)
                                             ;;(invoke-restart 'continue)
                                             (ignore-errors)
                                             ;;(invoke-restart 'abort)
                                             (print "aaaaaaaaaaa 2")
                                             ))
       ;;(cl-postgres-error:unique-violation (lambda (condition) (abort-web 200)))
       ;;(error (lambda (condition) (print "argh") (print condition) (error condition)))
       )
    (with-connection
        (postmodern:query (:insert-rows-into 'first_commits
                           :columns 'first_commit 'git_remote
                           :values (list (list first-commit git-remote)))))))

;; TODO (handler-bind (cl-postgres-error::* #'some-handler))
(defun query-select-fc-remotes (first-commit)
  (with-connection
      (postmodern:query (:select 'git_remote
                         :from 'first_commits
                         :where (:= 'first_commit first-commit)))))

(defun query-select-id-remotes (first-commit &optional ref)
  ;; TODO
  (declare (ignore ref))
  (with-connection
      (query-select-fc-remotes first-commit)))

#+end_src
**** Helper functions
#+name: helpers
#+begin_src lisp :results none
;;; helpers

(defun abort-db (condition)
  ;; TODO
  (declare (ignore condition))
  (abort-web 500))

(defun abort-web (&optional code)
  (setf (hunchentoot:return-code*) code)
  (hunchentoot:abort-request-handler))

(defun get-remotes (id)
  (destructuring-bind (&optional type first-commit ref)
      (uiop:split-string id :separator ":")
    (format *standard-output* "~s ~s ~s" type first-commit ref)
    (cond ((string= type "git")
           (if ref  ; implies first-commit
               (query-select-id-remotes first-commit ref)
               (if (and first-commit (not (string= first-commit "")))
                   (query-select-fc-remotes first-commit)
                   (abort-web 404))))
          (t (abort-web 404)))))
#+end_src
**** Remote patterns
#+begin_src lisp
;;; remote patterns
;; github
(named-readtables:in-readtable :interpol-syntax)
#?"https://github.com/${group}/${repo}"
#?"https://raw.githubusercontent.com/${group}/${repo}/${ref-or-rev}"
#?"https://github.com/${group}/${repo}/commit/${rev}"
(defun remote-to-uri (remote)
  ;; human, machine,
  (human)
)
#+end_src
**** Routes
#+name: routes
#+begin_src lisp :results none
;;; routes
(easy-routes:defroute post-git-fc
    ("/git/:first-commit" :method :post) (remote)
  (setf (hunchentoot:content-type*) "text/plain")
  ;; if known remote pattern check for first commit
  ;; if config parameter set to check all clone and validate first commit
  ;; if everything checks out add remote and first commit to database
  (setf (hunchentoot:return-code*) 201)  ; 200 returns on unique constraint violation
  (ignore-errors  ; WHY DO WE HAVE TO USE THIS !?!?!!
  (query-insert-fc first-commit remote))
  ;; wow ... it just... works ...
  (format nil "Register: git:~a -> ~a" first-commit remote))

(easy-routes:defroute get-resolve-id
    ("/resolve/:id" :method :get) ()
  (print (hunchentoot:headers-in hunchentoot:*request*))
  (if nil
      (progn 
        (setf (hunchentoot:content-type*) "text/plain")
        (format nil "Id ~a -> ~a" id (get-remotes id)))
      (progn
        (setf (hunchentoot:content-type*) "text/plain")
        (let ((remotes (get-remotes id)))
          ;;(format t "remotes: ~a" remotes)
          (if remotes
              (caar remotes)  ; list of lists coming back from the query, which is bad
              (abort-web 404))))))

(easy-routes:defroute get-git-fc
    ("/git/:first-commit" :method :get) ()
  (setf (hunchentoot:content-type*) "text/plain")
  (let ((results (query-select-fc-remotes first-commit)))
    (format nil "Id: git:~a -> ~a" first-commit results)))

(easy-routes:defroute get-git-fc-ref
    ("/git/:first-commit/:ref" :method :get) ()
  (setf (hunchentoot:content-type*) "text/plain")
  (format-git-id first-commit ref))
#+end_src

# Just here to say that being able to C-x C-e the sexp and have
# the bug go away on the live server is really satisfying
*** test
**** cl
Use =dexador= as our http client.
#+begin_src lisp :results none
(ql:quickload :dexador)
#+end_src

#+begin_src lisp :results drawer
(dex:post (concatenate 'string
                       "http://localhost:4242/git/e6cf3a391686a0b49171b9b195da88e81125bb1e"
                       "?remote=https://github.com/tgbugs/git-share.git"))
#+end_src

#+RESULTS:
:results:
"Register: git:e6cf3a391686a0b49171b9b195da88e81125bb1e -> https://github.com/tgbugs/git-share.git"
200
#<HASH-TABLE :TEST EQUAL :COUNT 4 {100184ACD3}>
#<QURI.URI.HTTP:URI-HTTP http://localhost:4242/git/e6cf3a391686a0b49171b9b195da88e81125bb1e?remote=https://github.com/tgbugs/git-share.git>
#<SB-SYS:FD-STREAM for "socket 127.0.0.1:56800, peer: 127.0.0.1:4242" {10090E1583}>
:end:

#+begin_src lisp :results drawer
(dex:get "http://localhost:4242/git/e6cf3a391686a0b49171b9b195da88e81125bb1e")
#+end_src

#+RESULTS:
:results:
"Id: git:e6cf3a391686a0b49171b9b195da88e81125bb1e -> ((git@github.com:tgbugs/git-share.git)
                                                     (https://github.com/tgbugs/git-share.git))"
200
#<HASH-TABLE :TEST EQUAL :COUNT 4 {10054BBCB3}>
#<QURI.URI.HTTP:URI-HTTP http://localhost:4242/git/e6cf3a391686a0b49171b9b195da88e81125bb1e>
#<SB-SYS:FD-STREAM for "socket 127.0.0.1:56820, peer: 127.0.0.1:4242" {10054B9EA3}>
:end:

#+begin_src lisp :results drawer
(dex:get "http://localhost:4242/resolve/git:e6cf3a391686a0b49171b9b195da88e81125bb1e")
#+end_src

#+RESULTS:
:results:
"git@github.com:tgbugs/git-share.git"
200
#<HASH-TABLE :TEST EQUAL :COUNT 4 {1005667543}>
#<QURI.URI.HTTP:URI-HTTP http://localhost:4242/resolve/git:e6cf3a391686a0b49171b9b195da88e81125bb1e>
#<SB-SYS:FD-STREAM for "socket 127.0.0.1:56926, peer: 127.0.0.1:4242" {1005665813}>
:end:

**** bash/curl
#+header: :shebang "#!/usr/bin/env sh" :mkdirp yes
#+begin_src bash :var TEST_HOST="localhost" :results output :tangle ./test/test-curl.sh
time for i in {0..9999}; do echo $i; done | \
xargs -P15 -r -n 1 -- curl -s -X GET \
http://${TEST_HOST}:4242/git/e6cf3a391686a0b49171b9b195da88e81125bb1e -H 2>&1 > /dev/null
#+end_src

|  time | avg       |
|-------+-----------|
|   6.8 | 6.8072857 |
|   6.7 | 1469.0143 |
| 6.542 |           |
| 7.323 |           |
| 7.045 | slad      |
| 6.306 |           |
| 6.935 | slad      |
#+TBLFM: @2$2=vmean(@2$1..@>$1)
#+TBLFM: @3$2=(10000 / @2$2)

**** queries
# TODO use =with-connection= instead
Run this in your repl if you are going to run these directly.
Might be able to unify =with-connection= and =query= for both
repl and server, aka swank and hunchentoot. As long as we don't
have multiple databases that we need to query within a single
namespace this should be ok.

#+name: connect-toplevel
#+begin_src lisp :noweb yes
(defparameter *db-connection*
  (postmodern:connect-toplevel
   "<<db-name>>"
   "<<user-name>>"
   "gsu123"
   "localhost"))
#+end_src

#+begin_src elisp :noweb yes :results drawer :wrap src lisp
(pp '
 <<connect-toplevel>>)
#+end_src

#+RESULTS:
#+begin_src lisp
(defparameter *db-connection*
  (postmodern:connect-toplevel "git_share_test" "git-share-user" "gsu123" "localhost"))
#+end_src


#+begin_src lisp
(postmodern:query (:select '* :from 'first_commits))
#+end_src

#+begin_src lisp
(postmodern:query "INSERT INTO first_commits (first_commit, git_remote)
                    VALUES ('6d96945e85d4e949215910f13f3e620495b5e165',
                            'https://github.com/tgbugs/pyontutils.git')")
#+end_src

** bash
NOTE there can be more than one first commit
#+begin_src bash :tangle ./bin/git-share-functions.sh
git-share-local () {
    find -type d -name '.git' \
         -exec git --git-dir={} rev-list --pretty="%H $(pwd)/{}" --max-parents=0 HEAD \; \
        | grep -v '^commit' | sed 's/\.git$//'
}

git-share-first-commit () {
    FC=$(git rev-list --max-parents=0 HEAD)
    for remote in $(git remote get-url --all origin); do
        curl -X POST "http://localhost:4242/git/${FC}?remote=${remote}"
    done
    # TODO always push to the local git-share instance first (sigh c)
    # and that will then deal with connecting to federated servers
}

git-share-all () {
    git remote get-url --all origin
}
# git-share-first-commit
# git-share-all
#+end_src
* Bootstrap :noexport:
#+name: orgstrap
#+begin_src elisp :lexical yes :noweb yes :results none
<<def-project-name-base>>

(defvar orgstrap-do-tangle nil "Override this for emacs --batch")

(defvar orgstrap-do-build nil "Override this for emacs --batch")

(defvar orgstrap-do-packages-system nil
  "Control whether to run code that fetches and installs external
dependencies. NOTE This implies `orgstrap-packages' t!")

;; TODO consider whether using an enumerate value might make more sense
;; e.g. orgstrap-deps '(nil :emacs :system) and then blocks could set
;; their requirements?
(defvar orgstrap-do-packages-emacs nil
  "Control whether to run code that fetchs and installs elisp packages.")

;; minimal reval

(unless (featurep 'reval)
  (defun reval-minimal (cypher checksum path-or-url &rest _alts)
    (let ((o url-handler-mode))
      (url-handler-mode)
      (unwind-protect
          (when (file-exists-p path-or-url)
            (let* ((buffer (find-file-noselect path-or-url))
                   (buffer-checksum (intern (secure-hash cypher buffer))))
              (if (eq buffer-checksum checksum)
                  (eval-buffer buffer)
                (kill-buffer buffer)
                (error "reval: checksum mismatch! %s" path-or-url))))
        (unless o
          (url-handler-mode 0)))))
  (defalias 'reval #'reval-minimal))

;; ow

(unless (featurep 'ow-min)
  (reval 'sha256 '3282d9328e05a12595ffc13e5afbeb3b3a76f1e3c45d50a53df39c2afd6ca341 "https://raw.githubusercontent.com/tgbugs/orgstrap/1e1fa08f9c1c059b393f737fcf19b55082bf660/ow-min.el"))

;; local defuns

(defun orgstrap---make ()
  "local function to run any extra steps required to build outputs"
  (let ((exec-path
         (cons (concat default-directory "bin")
               exec-path)))
    (concat
     "\nsbcl build:\n"
     (run-command "build-image-sbcl")
     "\necl build:\n"
     (run-command "build-image-ecl"))))

(defun orgstrap---make-not-quite ()
  "local function to run any extra steps required to build outputs"
  ' ; unfortunately the semantics of --eval and progn mean that we
  ;; can't use this approach easily because everything is read at
  ;; the same time so the namespaces for uiop: and ql: are missing
  (prog1 ;;concat
      ;;"\nsbcl build:\n"
      (orgstrap--with-block "build-image-sbcl"
        (let ((rbody (concat "(progn\n" body "\n)"))
              (print-escape-newlines nil))
          (message "%S" rbody)
          (run-command "sbcl"
                       ;;"--script"
                       "--noinform"
                       "--disable-ldb"
                       "--lose-on-corruption"
                       "--end-runtime-options"
                       "--noprint"
                       ;;"--no-sysinit"
                       "--no-userinit"
                       "--disable-debugger"
                       "--eval" rbody
                       "--eval" "(sb-ext:quit)")))
    "\necl build:\n"
    (orgstrap--with-block "build-image-ecl"
      ;; for some reason the script version of this works without issue
      ;; but this version can't find
      (let ((rbody (concat "(progn\n" body "\n)"))
            (print-escape-newlines nil))
        (message "%S" rbody)
        (run-command "ecl" "-q" "--norc" "--eval" rbody)))))

(defun orgstrap---system ()
  "Install system packages.
The simplest way to do this is to use a block for org babel language that can
be run as root. Unfortunately elisp does not work with :dir /su:: at the moment.

My general advice would be to specify system dependencies using the native
tooling for each package manager that you want to support. I suggest using
get-emacs.el.sh.ps1 as the basis for this since it can be run as root.
"
)
;; system packages go first in case elisp packages depend on them
(when orgstrap-do-packages-system
  (orgstrap---system))

(when (or orgstrap-do-packages-system orgstrap-do-packages-emacs)
  (orgstrap---packages))

(when (or orgstrap-do-tangle orgstrap-do-build)
  (org-babel-tangle)
  (when orgstrap-do-build
    (orgstrap---make)))

;; TODO org-babel-do-load-languages
(org-babel-do-load-languages
   'org-babel-load-languages
   '((lisp . t)))

;; TODO slime (needs reval) have to set inferior lisp etc
(condition-case nil
  (require 'slime)
  (error (package-install 'slime)))
#+end_src

#+name orgstrap-system
#+begin_src bash :dir /su::
id
#+end_src

#+RESULTS:
| uid=0(root) gid=0(root) groups=0(root) | 1(bin) | 2(daemon) | 3(sys) | 4(adm) | 6(disk) | 10(wheel) | 11(floppy) | 26(tape) | 27(video) |

** Local Variables :ARCHIVE:

# Local Variables:
# eval: (progn (setq-local orgstrap-min-org-version "8.2.10") (let ((actual (org-version)) (need orgstrap-min-org-version)) (or (fboundp #'orgstrap--confirm-eval) (not need) (string< need actual) (string= need actual) (error "Your Org is too old! %s < %s" actual need))) (defun orgstrap-norm-func--prp-1\.1 (body) (let (print-quoted print-length print-level) (prin1-to-string (read (concat "(progn\n" body "\n)"))))) (unless (boundp 'orgstrap-norm-func) (defvar orgstrap-norm-func orgstrap-norm-func-name)) (defun orgstrap-norm-embd (body) (funcall orgstrap-norm-func body)) (unless (fboundp #'orgstrap-norm) (defalias 'orgstrap-norm #'orgstrap-norm-embd)) (defun orgstrap-org-src-coderef-regexp (_fmt &optional label) (let ((fmt org-coderef-label-format)) (format "\\([:blank:]*\\(%s\\)[:blank:]*\\)$" (replace-regexp-in-string "%s" (if label (regexp-quote label) "\\([-a-zA-Z0-9_][-a-zA-Z0-9_ ]*\\)") (regexp-quote fmt) nil t)))) (unless (fboundp #'org-src-coderef-regexp) (defalias 'org-src-coderef-regexp #'orgstrap-org-src-coderef-regexp)) (defun orgstrap--expand-body (info) (let ((coderef (nth 6 info)) (expand (if (org-babel-noweb-p (nth 2 info) :eval) (org-babel-expand-noweb-references info) (nth 1 info)))) (if (not coderef) expand (replace-regexp-in-string (org-src-coderef-regexp coderef) "" expand nil nil 1)))) (defun orgstrap--confirm-eval-portable (lang _body) (not (and (member lang '("elisp" "emacs-lisp")) (let* ((body (orgstrap--expand-body (org-babel-get-src-block-info))) (body-normalized (orgstrap-norm body)) (content-checksum (intern (secure-hash orgstrap-cypher body-normalized)))) (eq orgstrap-block-checksum content-checksum))))) (defalias 'orgstrap--confirm-eval #'orgstrap--confirm-eval-portable) (let ((ocbe org-confirm-babel-evaluate)) (setq-local orgstrap-norm-func orgstrap-norm-func-name) (setq-local org-confirm-babel-evaluate #'orgstrap--confirm-eval) (unwind-protect (save-excursion (org-babel-goto-named-src-block "orgstrap") (org-babel-execute-src-block)) (setq-local org-confirm-babel-evaluate ocbe) (org-set-startup-visibility))))
# End:

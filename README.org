#+TITLE: git-share a git repository resolver

#+name: project-description-short
#+header: :results value drawer
#+begin_src elisp :exports results :eval no-export
"A git repository registration service and resolver."
#+end_src

#+RESULTS: project-description-short
:results:
A git repository registration service and resolver.
:end:

* Background
What if I could run =git share= in a repository to tell the world that I had a copy of a
git repository available somewhere? Using the first commit hash of a repo as a unique ID
for that repository (multi-parent aside) resolution to individual copies is the achieved
via a many-to-one mapping from the first commit hash to registered remotes.

=git share --all= could also automatically include all remotes in a =.git/config= as well.

Ids like =git:e6cf3a391686a0b49171b9b195da88e81125bb1e= can be resolved directly,
but there are no guarantees that the target repo will be up to date.

Using this mapping, a PID like
=git:e6cf3a391686a0b49171b9b195da88e81125bb1e:e6cf3a391686a0b49171b9b195da88e81125bb1e=
can be resolved easily if registered remotes have native support for commit resolution,
or at the very least can respond yes or to the question "Do you have a commit with this
hash?" In theory multiple sites could run instrumented repositories to enable this, and
in theory a registry could store the trees of hashes up to the point when =git share= is
run, perhaps as =git share --trees=.

The behavior of =share= could be configured as part of the global git config, of greatest
interest would be configuring which registries to use.

Automated metadata extraction to construct persistable metadata from a git repository is
another potential part of this. One complain about using bare git hashes is that there
isn't any metadata associated with them to provide context for/information about their
referent. In many cases this could be automatically extracted to provide more 'PIDness'
for the pure hash identifiers.

* Design
** endpoints
*** =/sexp=
port 80 endpoint that accepts sexps and nothing else
no http semantics at all
#+begin_src lisp :eval never
(git first-commit-hash ref)
#+end_src
*** =/repo=
**** =/repo/=
**** =/repo/submit=

**** =/resolve=
**** =/resolve/{first-commit}=
**** =/resolve/{first-commit}/{ref}=
in theory we can resolve shortened fragments until things become ambiguous
**** =/resolve?first-commit={first-commit}&ref={ref}=

**** =/git=
**** =/git/{first-commit}=
**** =/git/{first-commit}/{ref}=
in theory we can resolve shortened fragments until things become ambiguous
**** =/git?first-commit={first-commit}&ref={ref}=
* Code
#+name: project-name-base
: git-share

# sigh, inconsistency between eval, tangle, and export
#+name: project-name-safe
: git_share

** elisp
#+name: def-project-name-base
#+header: :noweb yes :results none 
#+begin_src emacs-lisp :exports none
(defun project-name (&optional suffix)
  "project name without - separator"
  (format "%s%s" "<<project-name-base()>>" (or suffix "")))
(defun project-name-base (suffix)
  (format "%s-%s" "<<project-name-base()>>" suffix))
(defun format-safe (string)
  (replace-regexp-in-string
    (regexp-quote "-")
    "_"
    string
    nil 'literal))
(defun project-db-name ()
  "<<db-name>>")
#+end_src

#+call: def-project-name-base()
# FIXME this needs to be called before tangling can continue ... how safely ...

** SQL
:PROPERTIES:
:header-args:sql: :mkdirp yes
:END:
*** vars
# :eval never is a hack around bad tangle behavior
#+name: schema-name
#+begin_src org :noweb yes
<<project-name-safe()>>
#+end_src

#+name: admin-name
#+begin_src org :noweb yes
<<project-name-base()>>-admin
#+end_src

#+name: user-name
#+begin_src org :noweb yes
<<project-name-base()>>-user
#+end_src

# TODO Change this for production, and/or find a way to branch without export pain.
#+name: db-name
#+begin_src org :noweb yes
<<project-name-safe()>>_test
#+end_src

*** code
:PROPERTIES:
:CREATED:  [2020-01-29 Wed 16:51]
:END:
#+name: postgres
#+header: :engine postgresql
#+header: :dbhost localhost
#+header: :dbuser postgres
#+header: :database postgres
#+header: :cmdline (format "-v database=%s" (project-db-name))
#+begin_src sql :noweb yes :tangle ./sql/postgres.sql
DO
$body$
BEGIN
    IF NOT EXISTS ( SELECT * FROM pg_catalog.pg_user
        WHERE usename = '<<user-name>>') THEN
        CREATE ROLE "<<user-name>>" LOGIN
        NOSUPERUSER INHERIT NOCREATEDB NOCREATEROLE;
    END IF;
    IF NOT EXISTS ( SELECT * FROM pg_catalog.pg_user
        WHERE usename = '<<admin-name>>') THEN
        CREATE ROLE "<<admin-name>>" LOGIN
        NOSUPERUSER INHERIT NOCREATEDB NOCREATEROLE;
    END IF;
END;
$body$ language plpgsql;

ALTER ROLE "<<admin-name>>" SET search_path = <<schema-name>>, public;
ALTER ROLE "<<user-name>>" SET search_path = <<schema-name>>, public;

DROP DATABASE IF EXISTS :database;

CREATE DATABASE :database
    WITH OWNER = '<<admin-name>>'
    ENCODING = 'UTF8'
    TABLESPACE = pg_default
    LC_COLLATE = 'en_US.UTF-8'  -- this was a gentoo locale issue check ${LANG}
    LC_CTYPE = 'en_US.UTF-8'
    CONNECTION LIMIT = -1;
#+end_src

The first time only set passwords and put them in [[file:~/.pgpass]].
This requires interactive session, e.g. via =M-x sql-postgres=.
The [[psql-interactive][psql-interactive]] block below this example will
launch the appropriate interactive session to set the passwords. Your user
will need to have permission to login as =postgres= or you need to have set
the postgres password in [[file:~/.pgpass]] e.g. via a line like
=localhost:5432:*:postgres:the-pg-p4ssw0rd=.

#+header: :dbuser postgres
#+header: :database postgres
#+begin_src sql :noweb yes :eval never
\password '<<admin-name>>'
\password '<<user-name>>'
\quit
#+end_src

#+name: psql-interactive
#+header: :results silent
#+begin_src elisp :eval no-export :var this-org-buffer=(buffer-name (current-buffer))
;; required to get the expected behavior when setting passwords
;; otherwise the second prompt "Enter it again:" fails to match
(when (not (string-match "it\\\\\|Response" comint-password-prompt-regexp))
  (setq comint-password-prompt-regexp
        (let ((sl (split-string comint-password-prompt-regexp "Response")))
          (concat (car sl) "it\\|Response" (cadr sl)))))

(setq sql-postgres-login-params
      '((user :default "postgres")
        (database :default "postgres")
        (server :default "localhost")
        (port :default 5432)))
;; TODO this doesn't work due to how orb babel calls elisp NOT due to buffer confusion
;; https://emacs.stackexchange.com/questions/42096/running-elisp-within-an-orgmode-code-block
(let ((buffer (sql-postgres)))
  (with-current-buffer (get-buffer this-org-buffer)
    (split-window-below)
    (windmove-down)
    (switch-to-buffer buffer)))
#+end_src

#+begin_src bash
layman -a tgbugs-overlay
emerge pguri
#+end_src

#+name: extensions
#+header: :engine postgresql
#+header: :dbhost localhost
#+header: :dbuser postgres
#+header: :database (project-db-name)
#+begin_src sql :noweb yes :tangle ./sql/extensions.sql
CREATE EXTENSION uri;
CREATE EXTENSION pgcrypto;
#+end_src

#+name: schemas
#+header: :engine postgresql
#+header: :dbhost localhost
#+header: :dbuser (project-name-base "admin")
#+header: :database (project-db-name)
#+begin_src sql :noweb yes :tangle ./sql/schemas.sql
CREATE SCHEMA IF NOT EXISTS <<schema-name>>;
#+end_src

#+name: tables
#+header: :engine postgresql
#+header: :dbhost localhost
#+header: :dbuser (project-name-base "admin")
#+header: :database (project-db-name)
#+begin_src sql :noweb yes :tangle ./sql/tables.sql
-- wrap table creation in a transaction block to avoid partial failures along the way
-- from resulting in future failures when tables already exist
DO
$body$
BEGIN

CREATE TABLE first_commits(
       first_commit char(40) NOT NULL,
       -- git_remote_uri uri NOT NULL -- FIXME git@github.com:tgbugs/git-share.git breaks this
       git_remote text NOT NULL,
       CONSTRAINT pk__first_commits PRIMARY KEY (first_commit, git_remote)
);

CREATE TABLE remote_trees(
       git_remote text NOT NULL
       -- tree NOT NULL -- TODO
);

CREATE TYPE mirror_type AS enum ('all', 'first-commits', 'none');
CREATE TYPE mirror_mode_type AS enum ('push', 'pull', 'both');

CREATE TABLE registries(
       uri text NOT NULL,
       last_contact timestamp NOT NULL,
       mirror mirror_type NOT NULL,
       mode mirror_mode_type NOT NULL
);

END;
$body$ language plpgsql;
#+end_src

#+name: permissions
#+header: :engine   postgresql
#+header: :dbhost   localhost
#+header: :dbuser   (project-name-base "admin")
#+header: :database (project-db-name)
#+header: :cmdline  (format "-v database=%s" (project-db-name))
#+begin_src sql :noweb yes :tangle ./sql/permissions.sql
GRANT CONNECT
   ON DATABASE :database
   TO "<<user-name>>";

GRANT USAGE
   ON SCHEMA <<schema-name>>
   TO "<<user-name>>";

GRANT SELECT, INSERT
   ON ALL TABLES IN SCHEMA <<schema-name>>
   TO "<<user-name>>";  -- tables includes views

GRANT USAGE
   ON ALL SEQUENCES IN SCHEMA <<schema-name>>
   TO "<<user-name>>";

GRANT INSERT (first_commit, git_remote)
   ON <<schema-name>>.first_commits
   TO "<<user-name>>";
#+end_src

# annoyingly these call blocks all fail with weird bash errors
# because things like (project-db-name) are not evaluated first
# #+call: postgres()
# #+call: extensions()
# #+call: schemas()
# #+call: tables()
# #+call: permissions()

#+header: :shebang "#!/usr/bin/env bash" :mkdirp yes
#+begin_src bash :noweb yes :tangle (format "./bin/%s" (project-name-base "db-setup"))
# TODO sadly this is easier to do in bash
#+end_src

** cl
*** packages
#+name: package.lisp
#+begin_src lisp :noweb yes :tangle ./package.lisp
(in-package :cl-user)
(defpackage #:<<project-name-base()>>
  (:use
   #:cl
   ; reminder that deps do not go in :use
   ;#:cl-who
   ;#:hunchentoot
   ;#:easy-routes
   ;#:postmodern
)
  (:export #:server-start
           #:server-stop
)
)

(defpackage #:<<project-name-base()>>/daemon
  (:use
   #:cl
   #:<<project-name-base()>>
   ; reminder that deps do not go in :use
   ;#:cl-daemonize
   ;#:swank
))
#+end_src

#+name: project-asd
#+begin_src lisp :noweb yes :tangle (format "./%s" (project-name ".asd"))
(in-package :cl-user)
(defpackage :<<project-name-base()>>-asd
  (:use #:cl #:asdf))
(in-package :<<project-name-base()>>-asd)

(defsystem :<<project-name-base()>>
  :version "0.0.1"
  :author "Tom Gillespie <tgbugs@gmail.com>"
  :license "GPL2"  ; match the git license need to check compat with other things here
  :description <<project-description-short>>
  :depends-on ("cl-who"
               "hunchentoot"
               "easy-routes"
               "postmodern")
  :serial t  ; needed so that packages loads before the others
  :components ((:file "package")
               (:file "core")))

#+()
(defsystem :<<project-name-base()>>/daemon
  :depends-on (:<<project-name-base()>>
               "cl-daemonize"
               "swank")
  ;;:components ((:file "daemon"))  ; explicitly don't load the file since it is a script
)

(defsystem :<<project-name-base()>>/small-start
  :depends-on (:<<project-name-base()>>
               "swank"))

(defsystem :<<project-name-base()>>/test
  :depends-on (:<<project-name-base()>>)
  :components ((:module "test"
                        :serial t
                        :components ((:file "package")
                                     (:file "tests")))))

#+end_src
*** parse args
#+name: parse-args-cli
#+begin_src lisp
(defun norm-arg (arg)
  ; FIXME type decls here would help
  ; FIXME parse-integer ignores leading zeros!
  (let ((int (ignore-errors (parse-integer arg))))
    (if int int arg)))

(defun pk (element)
  (when (not (listp element))
    (error (format nil "~s not a list!" element)))
  (let* ((kw (car element))
         (sl (string-downcase (symbol-name kw)))
         (assign (cdr element))  ; FIXME default?
         ;;(real-assign (if assign (car assign) (intern (symbol-name kw))))
         (real-assign (intern (symbol-name kw)))
         (default (if assign (car assign) assign)) ; FIXME
         (p (if assign
                `(progn (setq ,real-assign (norm-arg (cadr args))) (setq args (cddr args)))
                `(progn (setq ,real-assign t) (setq args (cdr args))))))
    (list `(,real-assign ,default)
          `(,(intern (format nil "--~a" sl)) ,p)
          `(cons ',real-assign ,real-assign))))

(defmacro parse-args (&body keywords)
  "(parse-args (:port port) (:pid pid) (:flag))"
  ;;(print (apply #'mapcar #'list (map 'list #'pk keywords)))
  ;;(format *standard-output* "~s~%" keywords)
  ;;`(,@keywords)
  `(quote ,keywords)
  (destructuring-bind (defaults cases returns)
      (apply #'mapcar #'list (map 'list #'pk keywords))
    `(let ((args (cdr sb-ext:*posix-argv*))
           ,@defaults)
       (do ()
           ((null args) nil)
         (case (intern (car args))
           ,@cases
           (otherwise (progn (format *standard-output* "unhandled: ~s~%" (car args))
                             (setq args (cdr args))))))
       (list ,@returns))))
#+end_src

#+header: :shebang "#!/usr/bin/sbcl --script" :tangle-mode (identity #o0755)
#+begin_src lisp :noweb yes :tangle ./args-test :results output
<<parse-args-cli>>
(format *standard-output* "~s~%" sb-ext:*posix-argv*)
(format *standard-output* "~s~%" (parse-args (:qq nil)
                                             (:port 4242)
                                             (:pid "/tmp/<<project-name-base()>>.pid")
                                             (:flag)))
#+end_src

#+begin_src lisp :exports none :eval never
'
(let ((args (cdr sb-ext:*posix-argv*))
      (port 4242)
      (pid  "/run/asdf/pid"))

  (do ()
      ((null args) nil)
    (case (intern (car args))
      (|--port| (progn (setq port (cadr args))
                       (setq args (cddr args))))
      (|--pid| (progn (setq pid (cadr args))
                      (setq args (cddr args))))
      (otherwise (progn (format *standard-output* "unhandled: ~s~%" (car args))
                        (setq args (cdr args))))))
  (print (list port pid)))
#+end_src
*** deployment
**** daemon
self daemonizing approach
#+header: :shebang "#!/usr/bin/sbcl --script"
#+header: :tangle-mode (identity #o0755)
#+begin_src lisp :noweb yes :tangle "./daemon.lisp"
#-quicklisp
(let ((quicklisp-init (merge-pathnames "code/lisp/quicklisp/setup.lisp"
                                       (user-homedir-pathname))))
  (when (probe-file quicklisp-init)
    (load quicklisp-init)))

;(require 'uiop)
;(require 'asdf)

(push (uiop:truenamize #p"~/git/NOFORK/cl-daemonize") ql:*local-project-directories*)
(push (uiop:truenamize #p"~/git/<<project-name-base()>>") ql:*local-project-directories*)
(ql:quickload :<<project-name-base()>>/daemon)
;(ql:quickload :<<project-name-base()>>)
;(ql:quickload '(cl-daemonize swank))
;(push (uiop:truenamize #p"~/git/<<project-name-base()>>") asdf:*central-registry*)
;(asdf:load-system :<<project-name-base()>>/daemon)  ; fixme recursion surely

;(load (uiop:truenamize "~/.emacs.d/elpa/slime-20191224.2328/swank-loader.lisp"))

(in-package :<<project-name-base()>>/daemon)

(defparameter *finished* nil)

<<parse-args-cli>>

(let ((args (parse-args (:port 4242)
                        (:pid #p"/tmp/<<project-name-base()>>.pid")
                        ;; FIXME apparently can't log into the git folder or something !?
                        (:path-log-out #p"/tmp/debug-out.log")
                        (:path-log-err #p"/tmp/debug-err.log"))))
     (defparameter *port* (cdr (assoc 'port args)))
     (defparameter *path-pid* (cdr (assoc 'pid args)))
     (defparameter *path-log-out* (cdr (assoc 'path-log-out args)))
     (defparameter *path-log-err* (cdr (assoc 'path-log-err args)))
)

(format *error-output* "~a ~a~%" *port* *path-pid*)
(format *standard-output* "~a ~a~%" *port* *path-pid*)

(cl-daemonize:daemonize :out *path-log-out* ;"output.log"
                        :err *path-log-err* ;"error.log"
                        :pid *path-pid*
                        :stop (lambda (&rest args)
                                (declare (ignore args))
                                (setf *finished* t)))

;(swank-loader:init)
(swank:create-server :port 4006)
(git-share:server-start :port *port*)

(format *standard-output* "STARTED~%")
(loop :do
     (sleep 1)
     (when *finished*
       (format *standard-output* "DONE~%")
       (git-share:server-stop)
       (sb-ext:quit)))

#+end_src
**** SLaD
So. Of all the many ways that one can try to package this thing to run
this is the one that amuses me the most deeply. 15mb. Sure you need a
copy of sbcl on the server, but still ... wow.

Tangle and run build-image to create a core dump that can be loaded on another system.
#+name: slad
#+header: :shebang "#!/usr/bin/sbcl --script"
#+header: :tangle-mode (identity #o0755)
#+begin_src lisp :tangle ./build-image
(load "bootstrap-image.lisp")
(save-lisp-and-die "git-share-start-small" :toplevel #'main :executable t :compression t)
#+end_src

#+begin_src lisp :noweb yes :tangle ./bootstrap-image.lisp
#-quicklisp
(let ((quicklisp-init (merge-pathnames "code/lisp/quicklisp/setup.lisp"
                                       (user-homedir-pathname))))
  (when (probe-file quicklisp-init)
    (load quicklisp-init)))

(push (uiop:truenamize #p"~/git/<<project-name-base()>>") ql:*local-project-directories*)
(ql:quickload :<<project-name-base()>>/small-start)

(defparameter *finished* nil)

<<parse-args-cli>>

(defun main ()
  (format t "~s~%" sb-ext:*posix-argv*)
  (let* ((args (parse-args (:port 4242)
                           (:pid #p"/tmp/<<project-name-base()>>.pid")
                           (:port-swank 4006)))
         (*port* (cdr (assoc 'port args)))
         (*path-pid* (cdr (assoc 'pid args)))
         (*port-swank* (cdr (assoc 'port-swank args))))
    (swank:create-server :port *port-swank*)
    (git-share:server-start :port *port*))

  (format t "STARTED~%")
  (loop :do
       (sleep 5)
       (when *finished*
         (format t "DONE~%")
         (git-share:server-stop)
         (sb-ext:quit)))
  )
#+end_src

It seems like =app-misc/detachtty= may be needed to get this to work.
Or the eternal loop might work as well. Needs more testing.

#+name: open-rc-init-script-slad
#+begin_src bash :tangle ./git-share-slad.rc
#!/sbin/openrc-run
# Copyright 1999-2020 Gentoo Authors
# Distributed under the terms of the GNU General Public License v2

: ${LOG_LEVEL:=info}
: ${SVCGROUP:=git-share}
: ${SVCUSER:=git-share}
: ${LOG_LOC:="/var/log/git-share"}

run_dir=${run_dir:-/run}
LOG="${LOG_LOC}/sysout.log"

pidfile="${run_dir}/${SVCNAME}/pid"
start_stop_daemon_args="
--group ${SVCGROUP}
--user ${SVCUSER}
--wait 1000
--env DOWENEEDENV=${SOMEENV}
"
command="/usr/bin/sbcl"
command_args="--port ${PORT}
--port-swank ${PORT_SWANK}"
retry='TERM/30/KILL/5'

command_owner="${SVCUSER}:${SVCGROUP}"

depend() {
    after net
}

start_pre() {
    local OOPS=0
    if [[ "${HRM_API}" == *"some-value"* ]] && [ -z "${HRM_KEY}" ]; then
        eend 1 durn
        OOPS=1
    fi
    if [ ${OOPS} -ne 0 ]; then
        return 1
    fi
    checkpath --directory --owner ${command_owner} --mode 0775 "/run/${SVCNAME}"
    checkpath --directory --owner ${command_owner} --mode 0775 "${LOG_LOC}"
}
#+end_src
**** foreground
Maybe a smaller version that uses openrc instead of self daemonizing
to be a bit friendly/more interoperable with posix conventions?
http://theatticlight.net/posts/A-Lisp-Daemon/
https://www.darkchestnut.com/2016/daemonizing-common-lisp-services/
https://www.reddit.com/r/Common_Lisp/comments/4n7ly6/daemonizing_common_lisp_services/

#+name: small-start
#+header: :shebang "#!/usr/bin/sbcl --script"
#+header: :tangle-mode (identity #o0755)
#+begin_src lisp :noweb yes :tangle ./small-start.lisp
#-quicklisp
(let ((quicklisp-init (merge-pathnames "code/lisp/quicklisp/setup.lisp"
                                       (user-homedir-pathname))))
  (when (probe-file quicklisp-init)
    (load quicklisp-init)))

(push (uiop:truenamize #p"~/git/<<project-name-base()>>") ql:*local-project-directories*)
(ql:quickload :<<project-name-base()>>/small-start)

<<parse-args-cli>>

(let ((args (parse-args (:port 4242)
                        (:pid #p"/tmp/<<project-name-base()>>.pid")
                        ;; FIXME apparently can't log into the git folder or something !?
                        ;;(:path-log-out #p"/tmp/debug-out.log")
                        ;;(:path-log-err #p"/tmp/debug-err.log")
                        ;; log to sysout in daemon for this one
                        )))
  (defparameter *port* (cdr (assoc 'port args)))
  (defparameter *path-pid* (cdr (assoc 'pid args)))
  (defparameter *path-log-out* (cdr (assoc 'path-log-out args)))
  (defparameter *path-log-err* (cdr (assoc 'path-log-err args))))

(defparameter *finished* nil)

(swank:create-server :port 4006)
(git-share:server-start :port *port*)

(format *standard-output* "STARTED~%")
(loop :do
     (sleep 5)
     (when *finished*
       (format *standard-output* "DONE~%")
       (git-share:server-stop)
       (sb-ext:quit)))
#+end_src

#+name: open-rc-init-script
#+begin_src bash :tangle ./git-share.rc
#!/sbin/openrc-run
# Copyright 1999-2020 Gentoo Authors
# Distributed under the terms of the GNU General Public License v2

: ${LOG_LEVEL:=info}
: ${SVCGROUP:=git-share}
: ${SVCUSER:=git-share}
: ${LOG_LOC:="/var/log/git-share"}

run_dir=${run_dir:-/run}
LOG="${LOG_LOC}/${SVCNAME}.log"

socket="unix:/run/${SVCNAME}/socket"

pidfile="${run_dir}/${SVCNAME}/pid"
start_stop_daemon_args="
--group ${SVCGROUP}
--user ${SVCUSER}
--wait 1000
--env DOWENEEDENV=${SOMEENV}
"
command="/usr/bin/sbcl"
command_args="--bind ${socket}
--port ${PORT}
--pid ${pidfile}"
retry='TERM/30/KILL/5'

command_owner="${SVCUSER}:${SVCGROUP}"

depend() {
    after net
}

start_pre() {
    OOPS=0
    if [ -z "${SCIGRAPH_API}" ]; then
        eend 1 "SCIGRAPH_API is not set in /etc/conf.d/${SVCNAME}"
        OOPS=1
    fi
    if [[ "${SCIRGRAPH_API}" == *"scicrunch"* ]] && [ -z "${SCIGRAPH_API_KEY}" ]; then
        eend 1 "SCIGRAPH_API requires SCIGRAPH_API_KEY not set in /etc/conf.d/${SVCNAME}"
        OOPS=1
    fi
    if [ ${OOPS} -ne 0 ]; then
        return 1
    fi
    checkpath --directory --owner ${command_owner} --mode 0775 "/run/${SVCNAME}"
    checkpath --directory --owner ${command_owner} --mode 0775 "${LOG_LOC}"
}
#+end_src
*** core
Connection handling
https://www.mail-archive.com/postmodern-devel@common-lisp.net/msg00348.html
https://sites.google.com/site/sabraonthehill/postmodern-examples/postmodern-connections

#+name: core
#+begin_src lisp :noweb yes :tangle ./core.lisp
#-(and)(
        (ql:quickload :cl-who)
        (ql:quickload :hunchentoot)
        (ql:quickload :easy-routes)
        (ql:quickload :postmodern)
        (rename-package :postmodern :postmodern '(psql))
        )
(in-package :<<project-name-base()>>)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (rename-package :postmodern :postmodern '(psql)))

#-(and)
(defparameter *db-connection* (postmodern:connect-toplevel
                               <<db-name>>
                               "<<user-name>>"
                               "TODO-pgpass"
                               "localhost"
                               :port 5432))

(defparameter *db-connection-parameters* '("<<db-name>>" "<<user-name>>" "gsu123" "localhost" :pooled-p t))

(defmacro with-connection (&body body)
  `(postmodern:with-connection *db-connection-parameters*
     ,@body))

(defvar *acceptor* nil)

(defun server-start (&key (port 4242))
  (server-stop)
  (hunchentoot:start (setf *acceptor*
                           (make-instance 'easy-routes:routes-acceptor
                                          :port port))))

(defun server-stop ()
  (when *acceptor*
    (when (hunchentoot:started-p *acceptor*)
      (hunchentoot:stop *acceptor*))))

(defun format-git-id (first-commit &optional (ref ""))
  (format nil "Id: git:~a:~a" first-commit ref))

;;; queries
;(require 'cl-postgres)  ; cl-postgres-error should already be pulled in by ql:quickload postmodern

(defun query-insert-fc (first-commit git-remote)
  (handler-bind
      (
       (cl-postgres-error:unique-violation (lambda (condition)
                                            (declare (ignore condition))
                                            (print "aaaaaaaaaaa 1")
                                            ;(abort-web 200)
                                            (setf (hunchentoot:return-code*) 200)
                                            ;(invoke-restart 'continue)
                                            (ignore-errors)
                                            ;(invoke-restart 'abort)
                                            (print "aaaaaaaaaaa 2")
))
       ;(cl-postgres-error:unique-violation (lambda (condition) (abort-web 200)))
       ;(error (lambda (condition) (print "argh") (print condition) (error condition)))
)
    (with-connection
    (postmodern:query (:insert-rows-into 'first_commits
                          :columns 'first_commit 'git_remote
                           :values (list (list first-commit git-remote)))))))

;; TODO (handler-bind (cl-postgres-error::* #'some-handler))
(defun query-select-fc-remotes (first-commit)
  (with-connection
  (postmodern:query (:select 'git_remote
                 :from 'first_commits
                :where (:= 'first_commit first-commit)))))

(defun query-select-id-remotes (first-commit &optional ref)
  ;; TODO
  (with-connection
  (query-select-fc-remotes first-commit)))

;;; helpers

(defun abort-db (condition)
  ;; TODO
  (abort-web 500))

(defun abort-web (&optional code)
  (setf (hunchentoot:return-code*) code)
  (hunchentoot:abort-request-handler))

(defun parse-id (id)
  (destructuring-bind (&optional type first-commit ref)
      (uiop:split-string id :separator ":")
      (format *standard-output* "~s ~s ~s" type first-commit ref)
    (cond ((string= type "git")
           (if ref  ; implies first-commit
               (query-select-id-remotes first-commit ref)
               (if (and first-commit (not (string= first-commit "")))
                   (query-select-fc-remotes first-commit)
                   (abort-web 404))))
          (t (abort-web 404)))))

;;; routes
(easy-routes:defroute
 post-git-fc ("/git/:first-commit" :method :post) (remote)
 (setf (hunchentoot:content-type*) "text/plain")
 ;; if known remote pattern check for first commit
 ;; if config parameter set to check all clone and validate first commit
 ;; if everything checks out add remote and first commit to database
 (setf (hunchentoot:return-code*) 201)  ; 200 returns on unique constraint violation
 (ignore-errors  ; WHY DO WE HAVE TO USE THIS !?!?!!
 (query-insert-fc first-commit remote))
 ;; wow ... it just... works ...
 (format nil "Register: git:~a -> ~a" first-commit remote))

(easy-routes:defroute get-resolve-id
 ("/resolve/:id" :method :get) ()
 (setf (hunchentoot:content-type*) "text/plain")
 (format nil "Id ~a -> ~a" id (parse-id id)))

(easy-routes:defroute get-git-fc
 ("/git/:first-commit" :method :get) ()
 (setf (hunchentoot:content-type*) "text/plain")
 (let ((results (query-select-fc-remotes first-commit)))
   (format nil "Id: git:~a -> ~a" first-commit results)))

(easy-routes:defroute get-git-fc-ref
 ("/git/:first-commit/:ref" :method :get) ()
 (setf (hunchentoot:content-type*) "text/plain")
 (format-git-id first-commit ref))
#+end_src

*** test
#+begin_src bash :results drawer
curl -X POST http://localhost:4242/git/e6cf3a391686a0b49171b9b195da88e81125bb1e?remote=https://github.com/tgbugs/git-share.git
#+end_src

#+RESULTS:
:results:
Register: git:e6cf3a391686a0b49171b9b195da88e81125bb1e -> https://github.com/tgbugs/git-share.git
:end:

#+begin_src bash :results drawer
curl -X GET http://localhost:4242/git/e6cf3a391686a0b49171b9b195da88e81125bb1e
#+end_src

#+RESULTS:
:results:
Id: git:e6cf3a391686a0b49171b9b195da88e81125bb1e -> ((git@github.com:tgbugs/git-share.git)
                                                     (https://github.com/tgbugs/git-share.git))
:end:

#+begin_src bash
time for i in {0..9999}; do echo $i; done | \
xargs -P15 -r -n 1 -- curl -X GET http://localhost:4242/git/e6cf3a391686a0b49171b9b195da88e81125bb1e -H
#+end_src

|  time | avg       |
|-------+-----------|
|   6.8 | 6.8072857 |
|   6.7 | 1469.0143 |
| 6.542 |           |
| 7.323 |           |
| 7.045 | slad      |
| 6.306 |           |
| 6.935 | slad      |
#+TBLFM: @2$2=vmean(@2$1..@>$1)
#+TBLFM: @3$2=(10000 / @2$2)

Run this in your repl if you are going to run these directly.
Might be able to unify =with-connection= and =query= for both
repl and server, aka swank and hunchentoot. As long as we don't
have multiple databases that we need to query within a single
namespace this should be ok.

#+name: connect-toplevel
#+begin_src lisp :noweb yes
(defparameter *db-connection*
  (postmodern:connect-toplevel
   "<<db-name>>"
   "<<user-name>>"
   "gsu123"
   "localhost"))
#+end_src

#+begin_src elisp :noweb yes :results drawer :wrap src lisp
(pp '
 <<connect-toplevel>>)
#+end_src

#+RESULTS:
#+begin_src lisp
(defparameter *db-connection*
  (postmodern:connect-toplevel "git_share_test" "git-share-user" "gsu123" "localhost"))
#+end_src

#+begin_src lisp
(postmodern:query (:select '* :from 'first_commits))
#+end_src

#+begin_src lisp
(postmodern:query "INSERT INTO first_commits (first_commit, git_remote)
                    VALUES ('6d96945e85d4e949215910f13f3e620495b5e165',
                            'https://github.com/tgbugs/pyontutils.git')")
#+end_src

** bash
NOTE there can be more than one first commit
#+begin_src bash
function git-share-first-commit () {
    FC=$(git rev-list --max-parents=0 HEAD)
    for remote in $(git remote get-url --all origin); do
        curl -X POST "http://localhost:4242/git/${FC}?remote=${remote}"
    done
    # TODO always push to the local git-share instance first (sigh c)
    # and that will then deal with connecting to federated servers
}
function git-share-all () {
    git remote get-url --all origin
}
# git-share-first-commit
# git-share-all
#+end_src
